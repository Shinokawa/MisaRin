// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `bool_to_u8`

CpuBrushResult cpuBrushDrawStampRgba({
  required List<int> pixels,
  required int width,
  required int height,
  required double centerX,
  required double centerY,
  required double radius,
  required int colorArgb,
  required int brushShape,
  required int antialiasLevel,
  required double softness,
  required bool erase,
  required bool randomRotation,
  required int rotationSeed,
  required double rotationJitter,
  required bool snapToPixel,
  Uint8List? selection,
}) => RustLib.instance.api.crateApiCpuBrushCpuBrushDrawStampRgba(
  pixels: pixels,
  width: width,
  height: height,
  centerX: centerX,
  centerY: centerY,
  radius: radius,
  colorArgb: colorArgb,
  brushShape: brushShape,
  antialiasLevel: antialiasLevel,
  softness: softness,
  erase: erase,
  randomRotation: randomRotation,
  rotationSeed: rotationSeed,
  rotationJitter: rotationJitter,
  snapToPixel: snapToPixel,
  selection: selection,
);

CpuBrushResult cpuBrushDrawCapsuleSegmentRgba({
  required List<int> pixels,
  required int width,
  required int height,
  required double ax,
  required double ay,
  required double bx,
  required double by,
  required double startRadius,
  required double endRadius,
  required int colorArgb,
  required int antialiasLevel,
  required bool includeStartCap,
  required bool erase,
  Uint8List? selection,
}) => RustLib.instance.api.crateApiCpuBrushCpuBrushDrawCapsuleSegmentRgba(
  pixels: pixels,
  width: width,
  height: height,
  ax: ax,
  ay: ay,
  bx: bx,
  by: by,
  startRadius: startRadius,
  endRadius: endRadius,
  colorArgb: colorArgb,
  antialiasLevel: antialiasLevel,
  includeStartCap: includeStartCap,
  erase: erase,
  selection: selection,
);

CpuBrushResult cpuBrushFillPolygonRgba({
  required List<int> pixels,
  required int width,
  required int height,
  required List<double> vertices,
  required double radius,
  required int colorArgb,
  required int antialiasLevel,
  required double softness,
  required bool erase,
  Uint8List? selection,
}) => RustLib.instance.api.crateApiCpuBrushCpuBrushFillPolygonRgba(
  pixels: pixels,
  width: width,
  height: height,
  vertices: vertices,
  radius: radius,
  colorArgb: colorArgb,
  antialiasLevel: antialiasLevel,
  softness: softness,
  erase: erase,
  selection: selection,
);

CpuBrushResult cpuBrushDrawStampSegmentRgba({
  required List<int> pixels,
  required int width,
  required int height,
  required double startX,
  required double startY,
  required double endX,
  required double endY,
  required double startRadius,
  required double endRadius,
  required int colorArgb,
  required int brushShape,
  required int antialiasLevel,
  required bool includeStart,
  required bool erase,
  required bool randomRotation,
  required int rotationSeed,
  required double rotationJitter,
  required double spacing,
  required double scatter,
  required double softness,
  required bool snapToPixel,
  required bool accumulate,
  Uint8List? selection,
}) => RustLib.instance.api.crateApiCpuBrushCpuBrushDrawStampSegmentRgba(
  pixels: pixels,
  width: width,
  height: height,
  startX: startX,
  startY: startY,
  endX: endX,
  endY: endY,
  startRadius: startRadius,
  endRadius: endRadius,
  colorArgb: colorArgb,
  brushShape: brushShape,
  antialiasLevel: antialiasLevel,
  includeStart: includeStart,
  erase: erase,
  randomRotation: randomRotation,
  rotationSeed: rotationSeed,
  rotationJitter: rotationJitter,
  spacing: spacing,
  scatter: scatter,
  softness: softness,
  snapToPixel: snapToPixel,
  accumulate: accumulate,
  selection: selection,
);

CpuBrushResult cpuBrushDrawSprayRgba({
  required List<int> pixels,
  required int width,
  required int height,
  required List<double> points,
  required int colorArgb,
  required int brushShape,
  required int antialiasLevel,
  required double softness,
  required bool erase,
  required bool accumulate,
  Uint8List? selection,
}) => RustLib.instance.api.crateApiCpuBrushCpuBrushDrawSprayRgba(
  pixels: pixels,
  width: width,
  height: height,
  points: points,
  colorArgb: colorArgb,
  brushShape: brushShape,
  antialiasLevel: antialiasLevel,
  softness: softness,
  erase: erase,
  accumulate: accumulate,
  selection: selection,
);

CpuStreamlineResult cpuBrushApplyStreamlineSamples({
  required List<double> samples,
  required double strength,
}) => RustLib.instance.api.crateApiCpuBrushCpuBrushApplyStreamlineSamples(
  samples: samples,
  strength: strength,
);

class CpuBrushResult {
  final bool ok;
  final Uint32List pixels;

  const CpuBrushResult({required this.ok, required this.pixels});

  @override
  int get hashCode => ok.hashCode ^ pixels.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CpuBrushResult &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          pixels == other.pixels;
}

class CpuStreamlineResult {
  final bool ok;
  final Float32List samples;

  const CpuStreamlineResult({required this.ok, required this.samples});

  @override
  int get hashCode => ok.hashCode ^ samples.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CpuStreamlineResult &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          samples == other.samples;
}
