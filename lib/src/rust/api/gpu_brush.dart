// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `brush_cell`, `compute_dirty_rect_i32`, `create_wgpu_device`, `map_brush_shape`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `GpuBrushEngine`

void gpuBrushInit() => RustLib.instance.api.crateApiGpuBrushGpuBrushInit();

Future<void> gpuUploadLayer({
  required String layerId,
  required List<int> pixels,
  required int width,
  required int height,
}) => RustLib.instance.api.crateApiGpuBrushGpuUploadLayer(
  layerId: layerId,
  pixels: pixels,
  width: width,
  height: height,
);

Future<Uint32List> gpuDownloadLayer({required String layerId}) =>
    RustLib.instance.api.crateApiGpuBrushGpuDownloadLayer(layerId: layerId);

void gpuRemoveLayer({required String layerId}) =>
    RustLib.instance.api.crateApiGpuBrushGpuRemoveLayer(layerId: layerId);

void gpuBrushDispose() =>
    RustLib.instance.api.crateApiGpuBrushGpuBrushDispose();

Future<GpuStrokeResult> gpuDrawStroke({
  required String layerId,
  required List<GpuPoint2D> points,
  required List<double> radii,
  required int color,
  required int brushShape,
  required bool erase,
  required int antialiasLevel,
}) => RustLib.instance.api.crateApiGpuBrushGpuDrawStroke(
  layerId: layerId,
  points: points,
  radii: radii,
  color: color,
  brushShape: brushShape,
  erase: erase,
  antialiasLevel: antialiasLevel,
);

class GpuPoint2D {
  final double x;
  final double y;

  const GpuPoint2D({required this.x, required this.y});

  @override
  int get hashCode => x.hashCode ^ y.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GpuPoint2D &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y;
}

class GpuStrokeResult {
  final int dirtyLeft;
  final int dirtyTop;
  final int dirtyWidth;
  final int dirtyHeight;
  final Uint32List pixels;

  const GpuStrokeResult({
    required this.dirtyLeft,
    required this.dirtyTop,
    required this.dirtyWidth,
    required this.dirtyHeight,
    required this.pixels,
  });

  @override
  int get hashCode =>
      dirtyLeft.hashCode ^
      dirtyTop.hashCode ^
      dirtyWidth.hashCode ^
      dirtyHeight.hashCode ^
      pixels.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GpuStrokeResult &&
          runtimeType == other.runtimeType &&
          dirtyLeft == other.dirtyLeft &&
          dirtyTop == other.dirtyTop &&
          dirtyWidth == other.dirtyWidth &&
          dirtyHeight == other.dirtyHeight &&
          pixels == other.pixels;
}
