// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/bucket_fill.dart';
import 'api/gpu_brush.dart';
import 'api/gpu_composite.dart';
import 'api/image_ops.dart';
import 'api/memory.dart';
import 'api/psd.dart';
import 'api/selection_path.dart';
import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -425759915;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'rust_lib_misa_rin',
        ioDirectory: 'rust/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  BigInt crateApiMemoryAllocatePixelBuffer({required int size});

  Uint8List crateApiImageOpsConvertPixelsToRgba({required List<int> pixels});

  Future<FloodFillRect> crateApiBucketFillFloodFillInPlace({
    required BigInt ptr,
    required int width,
    required int height,
    Uint32List? samplePixels,
    required int startX,
    required int startY,
    required int colorValue,
    int? targetColorValue,
    required bool contiguous,
    required int tolerance,
    required int fillGap,
    Uint8List? selectionMask,
    Uint32List? swallowColors,
    required int antialiasLevel,
  });

  Future<FloodFillPatch> crateApiBucketFillFloodFillPatch({
    required int width,
    required int height,
    required List<int> pixels,
    Uint32List? samplePixels,
    required int startX,
    required int startY,
    required int colorValue,
    int? targetColorValue,
    required bool contiguous,
    required int tolerance,
    required int fillGap,
    Uint8List? selectionMask,
    Uint32List? swallowColors,
    required int antialiasLevel,
  });

  void crateApiMemoryFreePixelBuffer({required BigInt ptr, required int size});

  void crateApiGpuBrushGpuBrushDispose();

  void crateApiGpuBrushGpuBrushInit();

  Future<Uint32List> crateApiGpuCompositeGpuCompositeLayers({
    required List<GpuLayerData> layers,
    required int width,
    required int height,
  });

  void crateApiGpuCompositeGpuCompositorDispose();

  void crateApiGpuCompositeGpuCompositorInit();

  Future<Uint32List> crateApiGpuBrushGpuDownloadLayer({
    required String layerId,
  });

  Future<GpuStrokeResult> crateApiGpuBrushGpuDrawStroke({
    required String layerId,
    required List<GpuPoint2D> points,
    required List<double> radii,
    required int color,
    required int brushShape,
    required bool erase,
    required int antialiasLevel,
  });

  void crateApiGpuBrushGpuRemoveLayer({required String layerId});

  Future<void> crateApiGpuBrushGpuUploadLayer({
    required String layerId,
    required List<int> pixels,
    required int width,
    required int height,
  });

  String crateApiSimpleGreet({required String name});

  Future<PsdDocument> crateApiPsdImportPsd({required List<int> bytes});

  Future<void> crateApiSimpleInitApp();

  int crateApiMemoryReadPixelAt({required BigInt ptr, required int index});

  Uint32List crateApiSelectionPathSelectionPathVerticesFromMask({
    required List<int> mask,
    required int width,
  });
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  BigInt crateApiMemoryAllocatePixelBuffer({required int size}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(size, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMemoryAllocatePixelBufferConstMeta,
        argValues: [size],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMemoryAllocatePixelBufferConstMeta =>
      const TaskConstMeta(
        debugName: "allocate_pixel_buffer",
        argNames: ["size"],
      );

  @override
  Uint8List crateApiImageOpsConvertPixelsToRgba({required List<int> pixels}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiImageOpsConvertPixelsToRgbaConstMeta,
        argValues: [pixels],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiImageOpsConvertPixelsToRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "convert_pixels_to_rgba",
        argNames: ["pixels"],
      );

  @override
  Future<FloodFillRect> crateApiBucketFillFloodFillInPlace({
    required BigInt ptr,
    required int width,
    required int height,
    Uint32List? samplePixels,
    required int startX,
    required int startY,
    required int colorValue,
    int? targetColorValue,
    required bool contiguous,
    required int tolerance,
    required int fillGap,
    Uint8List? selectionMask,
    Uint32List? swallowColors,
    required int antialiasLevel,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_usize(ptr, serializer);
          sse_encode_i_32(width, serializer);
          sse_encode_i_32(height, serializer);
          sse_encode_opt_list_prim_u_32_strict(samplePixels, serializer);
          sse_encode_i_32(startX, serializer);
          sse_encode_i_32(startY, serializer);
          sse_encode_u_32(colorValue, serializer);
          sse_encode_opt_box_autoadd_u_32(targetColorValue, serializer);
          sse_encode_bool(contiguous, serializer);
          sse_encode_i_32(tolerance, serializer);
          sse_encode_i_32(fillGap, serializer);
          sse_encode_opt_list_prim_u_8_strict(selectionMask, serializer);
          sse_encode_opt_list_prim_u_32_strict(swallowColors, serializer);
          sse_encode_i_32(antialiasLevel, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 3,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_flood_fill_rect,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiBucketFillFloodFillInPlaceConstMeta,
        argValues: [
          ptr,
          width,
          height,
          samplePixels,
          startX,
          startY,
          colorValue,
          targetColorValue,
          contiguous,
          tolerance,
          fillGap,
          selectionMask,
          swallowColors,
          antialiasLevel,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBucketFillFloodFillInPlaceConstMeta =>
      const TaskConstMeta(
        debugName: "flood_fill_in_place",
        argNames: [
          "ptr",
          "width",
          "height",
          "samplePixels",
          "startX",
          "startY",
          "colorValue",
          "targetColorValue",
          "contiguous",
          "tolerance",
          "fillGap",
          "selectionMask",
          "swallowColors",
          "antialiasLevel",
        ],
      );

  @override
  Future<FloodFillPatch> crateApiBucketFillFloodFillPatch({
    required int width,
    required int height,
    required List<int> pixels,
    Uint32List? samplePixels,
    required int startX,
    required int startY,
    required int colorValue,
    int? targetColorValue,
    required bool contiguous,
    required int tolerance,
    required int fillGap,
    Uint8List? selectionMask,
    Uint32List? swallowColors,
    required int antialiasLevel,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(width, serializer);
          sse_encode_i_32(height, serializer);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_opt_list_prim_u_32_strict(samplePixels, serializer);
          sse_encode_i_32(startX, serializer);
          sse_encode_i_32(startY, serializer);
          sse_encode_u_32(colorValue, serializer);
          sse_encode_opt_box_autoadd_u_32(targetColorValue, serializer);
          sse_encode_bool(contiguous, serializer);
          sse_encode_i_32(tolerance, serializer);
          sse_encode_i_32(fillGap, serializer);
          sse_encode_opt_list_prim_u_8_strict(selectionMask, serializer);
          sse_encode_opt_list_prim_u_32_strict(swallowColors, serializer);
          sse_encode_i_32(antialiasLevel, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 4,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_flood_fill_patch,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiBucketFillFloodFillPatchConstMeta,
        argValues: [
          width,
          height,
          pixels,
          samplePixels,
          startX,
          startY,
          colorValue,
          targetColorValue,
          contiguous,
          tolerance,
          fillGap,
          selectionMask,
          swallowColors,
          antialiasLevel,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBucketFillFloodFillPatchConstMeta =>
      const TaskConstMeta(
        debugName: "flood_fill_patch",
        argNames: [
          "width",
          "height",
          "pixels",
          "samplePixels",
          "startX",
          "startY",
          "colorValue",
          "targetColorValue",
          "contiguous",
          "tolerance",
          "fillGap",
          "selectionMask",
          "swallowColors",
          "antialiasLevel",
        ],
      );

  @override
  void crateApiMemoryFreePixelBuffer({required BigInt ptr, required int size}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_usize(ptr, serializer);
          sse_encode_i_32(size, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMemoryFreePixelBufferConstMeta,
        argValues: [ptr, size],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMemoryFreePixelBufferConstMeta =>
      const TaskConstMeta(
        debugName: "free_pixel_buffer",
        argNames: ["ptr", "size"],
      );

  @override
  void crateApiGpuBrushGpuBrushDispose() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGpuBrushGpuBrushDisposeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuBrushDisposeConstMeta =>
      const TaskConstMeta(debugName: "gpu_brush_dispose", argNames: []);

  @override
  void crateApiGpuBrushGpuBrushInit() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuBrushGpuBrushInitConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuBrushInitConstMeta =>
      const TaskConstMeta(debugName: "gpu_brush_init", argNames: []);

  @override
  Future<Uint32List> crateApiGpuCompositeGpuCompositeLayers({
    required List<GpuLayerData> layers,
    required int width,
    required int height,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_gpu_layer_data(layers, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 8,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_32_strict,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuCompositeGpuCompositeLayersConstMeta,
        argValues: [layers, width, height],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuCompositeGpuCompositeLayersConstMeta =>
      const TaskConstMeta(
        debugName: "gpu_composite_layers",
        argNames: ["layers", "width", "height"],
      );

  @override
  void crateApiGpuCompositeGpuCompositorDispose() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGpuCompositeGpuCompositorDisposeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuCompositeGpuCompositorDisposeConstMeta =>
      const TaskConstMeta(debugName: "gpu_compositor_dispose", argNames: []);

  @override
  void crateApiGpuCompositeGpuCompositorInit() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuCompositeGpuCompositorInitConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuCompositeGpuCompositorInitConstMeta =>
      const TaskConstMeta(debugName: "gpu_compositor_init", argNames: []);

  @override
  Future<Uint32List> crateApiGpuBrushGpuDownloadLayer({
    required String layerId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(layerId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 11,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_32_strict,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuBrushGpuDownloadLayerConstMeta,
        argValues: [layerId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuDownloadLayerConstMeta =>
      const TaskConstMeta(
        debugName: "gpu_download_layer",
        argNames: ["layerId"],
      );

  @override
  Future<GpuStrokeResult> crateApiGpuBrushGpuDrawStroke({
    required String layerId,
    required List<GpuPoint2D> points,
    required List<double> radii,
    required int color,
    required int brushShape,
    required bool erase,
    required int antialiasLevel,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(layerId, serializer);
          sse_encode_list_gpu_point_2_d(points, serializer);
          sse_encode_list_prim_f_32_loose(radii, serializer);
          sse_encode_u_32(color, serializer);
          sse_encode_u_32(brushShape, serializer);
          sse_encode_bool(erase, serializer);
          sse_encode_u_32(antialiasLevel, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 12,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_gpu_stroke_result,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuBrushGpuDrawStrokeConstMeta,
        argValues: [
          layerId,
          points,
          radii,
          color,
          brushShape,
          erase,
          antialiasLevel,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuDrawStrokeConstMeta =>
      const TaskConstMeta(
        debugName: "gpu_draw_stroke",
        argNames: [
          "layerId",
          "points",
          "radii",
          "color",
          "brushShape",
          "erase",
          "antialiasLevel",
        ],
      );

  @override
  void crateApiGpuBrushGpuRemoveLayer({required String layerId}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(layerId, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuBrushGpuRemoveLayerConstMeta,
        argValues: [layerId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuRemoveLayerConstMeta =>
      const TaskConstMeta(debugName: "gpu_remove_layer", argNames: ["layerId"]);

  @override
  Future<void> crateApiGpuBrushGpuUploadLayer({
    required String layerId,
    required List<int> pixels,
    required int width,
    required int height,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(layerId, serializer);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 14,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuBrushGpuUploadLayerConstMeta,
        argValues: [layerId, pixels, width, height],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuUploadLayerConstMeta =>
      const TaskConstMeta(
        debugName: "gpu_upload_layer",
        argNames: ["layerId", "pixels", "width", "height"],
      );

  @override
  String crateApiSimpleGreet({required String name}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSimpleGreetConstMeta,
        argValues: [name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSimpleGreetConstMeta =>
      const TaskConstMeta(debugName: "greet", argNames: ["name"]);

  @override
  Future<PsdDocument> crateApiPsdImportPsd({required List<int> bytes}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(bytes, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 16,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_psd_document,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiPsdImportPsdConstMeta,
        argValues: [bytes],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsdImportPsdConstMeta =>
      const TaskConstMeta(debugName: "import_psd", argNames: ["bytes"]);

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 17,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSimpleInitAppConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta =>
      const TaskConstMeta(debugName: "init_app", argNames: []);

  @override
  int crateApiMemoryReadPixelAt({required BigInt ptr, required int index}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_usize(ptr, serializer);
          sse_encode_i_32(index, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMemoryReadPixelAtConstMeta,
        argValues: [ptr, index],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMemoryReadPixelAtConstMeta => const TaskConstMeta(
    debugName: "read_pixel_at",
    argNames: ["ptr", "index"],
  );

  @override
  Uint32List crateApiSelectionPathSelectionPathVerticesFromMask({
    required List<int> mask,
    required int width,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(mask, serializer);
          sse_encode_i_32(width, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_32_strict,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSelectionPathSelectionPathVerticesFromMaskConstMeta,
        argValues: [mask, width],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiSelectionPathSelectionPathVerticesFromMaskConstMeta =>
      const TaskConstMeta(
        debugName: "selection_path_vertices_from_mask",
        argNames: ["mask", "width"],
      );

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FloodFillPatch dco_decode_flood_fill_patch(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return FloodFillPatch(
      left: dco_decode_i_32(arr[0]),
      top: dco_decode_i_32(arr[1]),
      width: dco_decode_i_32(arr[2]),
      height: dco_decode_i_32(arr[3]),
      pixels: dco_decode_list_prim_u_32_strict(arr[4]),
    );
  }

  @protected
  FloodFillRect dco_decode_flood_fill_rect(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return FloodFillRect(
      left: dco_decode_i_32(arr[0]),
      top: dco_decode_i_32(arr[1]),
      width: dco_decode_i_32(arr[2]),
      height: dco_decode_i_32(arr[3]),
    );
  }

  @protected
  GpuLayerData dco_decode_gpu_layer_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return GpuLayerData(
      pixels: dco_decode_list_prim_u_32_strict(arr[0]),
      opacity: dco_decode_f_64(arr[1]),
      blendModeIndex: dco_decode_u_32(arr[2]),
      visible: dco_decode_bool(arr[3]),
      clippingMask: dco_decode_bool(arr[4]),
    );
  }

  @protected
  GpuPoint2D dco_decode_gpu_point_2_d(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GpuPoint2D(x: dco_decode_f_32(arr[0]), y: dco_decode_f_32(arr[1]));
  }

  @protected
  GpuStrokeResult dco_decode_gpu_stroke_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return GpuStrokeResult(
      dirtyLeft: dco_decode_i_32(arr[0]),
      dirtyTop: dco_decode_i_32(arr[1]),
      dirtyWidth: dco_decode_i_32(arr[2]),
      dirtyHeight: dco_decode_i_32(arr[3]),
      pixels: dco_decode_list_prim_u_32_strict(arr[4]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<GpuLayerData> dco_decode_list_gpu_layer_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_gpu_layer_data).toList();
  }

  @protected
  List<GpuPoint2D> dco_decode_list_gpu_point_2_d(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_gpu_point_2_d).toList();
  }

  @protected
  List<double> dco_decode_list_prim_f_32_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<double>;
  }

  @protected
  Float32List dco_decode_list_prim_f_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float32List;
  }

  @protected
  List<int> dco_decode_list_prim_u_32_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint32List dco_decode_list_prim_u_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint32List;
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<PsdLayer> dco_decode_list_psd_layer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_psd_layer).toList();
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  Uint32List? dco_decode_opt_list_prim_u_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_32_strict(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  PsdDocument dco_decode_psd_document(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PsdDocument(
      width: dco_decode_i_32(arr[0]),
      height: dco_decode_i_32(arr[1]),
      layers: dco_decode_list_psd_layer(arr[2]),
    );
  }

  @protected
  PsdLayer dco_decode_psd_layer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return PsdLayer(
      name: dco_decode_String(arr[0]),
      visible: dco_decode_bool(arr[1]),
      opacity: dco_decode_u_8(arr[2]),
      clippingMask: dco_decode_bool(arr[3]),
      blendModeKey: dco_decode_String(arr[4]),
      bitmap: dco_decode_list_prim_u_8_strict(arr[5]),
      bitmapWidth: dco_decode_i_32(arr[6]),
      bitmapHeight: dco_decode_i_32(arr[7]),
      bitmapLeft: dco_decode_i_32(arr[8]),
      bitmapTop: dco_decode_i_32(arr[9]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  FloodFillPatch sse_decode_flood_fill_patch(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_left = sse_decode_i_32(deserializer);
    var var_top = sse_decode_i_32(deserializer);
    var var_width = sse_decode_i_32(deserializer);
    var var_height = sse_decode_i_32(deserializer);
    var var_pixels = sse_decode_list_prim_u_32_strict(deserializer);
    return FloodFillPatch(
      left: var_left,
      top: var_top,
      width: var_width,
      height: var_height,
      pixels: var_pixels,
    );
  }

  @protected
  FloodFillRect sse_decode_flood_fill_rect(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_left = sse_decode_i_32(deserializer);
    var var_top = sse_decode_i_32(deserializer);
    var var_width = sse_decode_i_32(deserializer);
    var var_height = sse_decode_i_32(deserializer);
    return FloodFillRect(
      left: var_left,
      top: var_top,
      width: var_width,
      height: var_height,
    );
  }

  @protected
  GpuLayerData sse_decode_gpu_layer_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pixels = sse_decode_list_prim_u_32_strict(deserializer);
    var var_opacity = sse_decode_f_64(deserializer);
    var var_blendModeIndex = sse_decode_u_32(deserializer);
    var var_visible = sse_decode_bool(deserializer);
    var var_clippingMask = sse_decode_bool(deserializer);
    return GpuLayerData(
      pixels: var_pixels,
      opacity: var_opacity,
      blendModeIndex: var_blendModeIndex,
      visible: var_visible,
      clippingMask: var_clippingMask,
    );
  }

  @protected
  GpuPoint2D sse_decode_gpu_point_2_d(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_x = sse_decode_f_32(deserializer);
    var var_y = sse_decode_f_32(deserializer);
    return GpuPoint2D(x: var_x, y: var_y);
  }

  @protected
  GpuStrokeResult sse_decode_gpu_stroke_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_dirtyLeft = sse_decode_i_32(deserializer);
    var var_dirtyTop = sse_decode_i_32(deserializer);
    var var_dirtyWidth = sse_decode_i_32(deserializer);
    var var_dirtyHeight = sse_decode_i_32(deserializer);
    var var_pixels = sse_decode_list_prim_u_32_strict(deserializer);
    return GpuStrokeResult(
      dirtyLeft: var_dirtyLeft,
      dirtyTop: var_dirtyTop,
      dirtyWidth: var_dirtyWidth,
      dirtyHeight: var_dirtyHeight,
      pixels: var_pixels,
    );
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<GpuLayerData> sse_decode_list_gpu_layer_data(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GpuLayerData>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_gpu_layer_data(deserializer));
    }
    return ans_;
  }

  @protected
  List<GpuPoint2D> sse_decode_list_gpu_point_2_d(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GpuPoint2D>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_gpu_point_2_d(deserializer));
    }
    return ans_;
  }

  @protected
  List<double> sse_decode_list_prim_f_32_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  Float32List sse_decode_list_prim_f_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_32_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  Uint32List sse_decode_list_prim_u_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<PsdLayer> sse_decode_list_psd_layer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PsdLayer>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_psd_layer(deserializer));
    }
    return ans_;
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint32List? sse_decode_opt_list_prim_u_32_strict(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_32_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PsdDocument sse_decode_psd_document(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_width = sse_decode_i_32(deserializer);
    var var_height = sse_decode_i_32(deserializer);
    var var_layers = sse_decode_list_psd_layer(deserializer);
    return PsdDocument(
      width: var_width,
      height: var_height,
      layers: var_layers,
    );
  }

  @protected
  PsdLayer sse_decode_psd_layer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_visible = sse_decode_bool(deserializer);
    var var_opacity = sse_decode_u_8(deserializer);
    var var_clippingMask = sse_decode_bool(deserializer);
    var var_blendModeKey = sse_decode_String(deserializer);
    var var_bitmap = sse_decode_list_prim_u_8_strict(deserializer);
    var var_bitmapWidth = sse_decode_i_32(deserializer);
    var var_bitmapHeight = sse_decode_i_32(deserializer);
    var var_bitmapLeft = sse_decode_i_32(deserializer);
    var var_bitmapTop = sse_decode_i_32(deserializer);
    return PsdLayer(
      name: var_name,
      visible: var_visible,
      opacity: var_opacity,
      clippingMask: var_clippingMask,
      blendModeKey: var_blendModeKey,
      bitmap: var_bitmap,
      bitmapWidth: var_bitmapWidth,
      bitmapHeight: var_bitmapHeight,
      bitmapLeft: var_bitmapLeft,
      bitmapTop: var_bitmapTop,
    );
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_flood_fill_patch(
    FloodFillPatch self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.left, serializer);
    sse_encode_i_32(self.top, serializer);
    sse_encode_i_32(self.width, serializer);
    sse_encode_i_32(self.height, serializer);
    sse_encode_list_prim_u_32_strict(self.pixels, serializer);
  }

  @protected
  void sse_encode_flood_fill_rect(
    FloodFillRect self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.left, serializer);
    sse_encode_i_32(self.top, serializer);
    sse_encode_i_32(self.width, serializer);
    sse_encode_i_32(self.height, serializer);
  }

  @protected
  void sse_encode_gpu_layer_data(GpuLayerData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_32_strict(self.pixels, serializer);
    sse_encode_f_64(self.opacity, serializer);
    sse_encode_u_32(self.blendModeIndex, serializer);
    sse_encode_bool(self.visible, serializer);
    sse_encode_bool(self.clippingMask, serializer);
  }

  @protected
  void sse_encode_gpu_point_2_d(GpuPoint2D self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.x, serializer);
    sse_encode_f_32(self.y, serializer);
  }

  @protected
  void sse_encode_gpu_stroke_result(
    GpuStrokeResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.dirtyLeft, serializer);
    sse_encode_i_32(self.dirtyTop, serializer);
    sse_encode_i_32(self.dirtyWidth, serializer);
    sse_encode_i_32(self.dirtyHeight, serializer);
    sse_encode_list_prim_u_32_strict(self.pixels, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_list_gpu_layer_data(
    List<GpuLayerData> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_gpu_layer_data(item, serializer);
    }
  }

  @protected
  void sse_encode_list_gpu_point_2_d(
    List<GpuPoint2D> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_gpu_point_2_d(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_32_loose(
    List<double> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(
      self is Float32List ? self : Float32List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_f_32_strict(
    Float32List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(self);
  }

  @protected
  void sse_encode_list_prim_u_32_loose(
    List<int> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint32List(
      self is Uint32List ? self : Uint32List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_u_32_strict(
    Uint32List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
    List<int> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(
      self is Uint8List ? self : Uint8List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_psd_layer(
    List<PsdLayer> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_psd_layer(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_32_strict(
    Uint32List? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_32_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
    Uint8List? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_psd_document(PsdDocument self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.width, serializer);
    sse_encode_i_32(self.height, serializer);
    sse_encode_list_psd_layer(self.layers, serializer);
  }

  @protected
  void sse_encode_psd_layer(PsdLayer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_bool(self.visible, serializer);
    sse_encode_u_8(self.opacity, serializer);
    sse_encode_bool(self.clippingMask, serializer);
    sse_encode_String(self.blendModeKey, serializer);
    sse_encode_list_prim_u_8_strict(self.bitmap, serializer);
    sse_encode_i_32(self.bitmapWidth, serializer);
    sse_encode_i_32(self.bitmapHeight, serializer);
    sse_encode_i_32(self.bitmapLeft, serializer);
    sse_encode_i_32(self.bitmapTop, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}
