// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/bucket_fill.dart';
import 'api/cpu_blend.dart';
import 'api/cpu_brush.dart';
import 'api/cpu_filters.dart';
import 'api/cpu_image.dart';
import 'api/cpu_transform.dart';
import 'api/gpu_brush.dart';
import 'api/gpu_composite.dart';
import 'api/image_ops.dart';
import 'api/memory.dart';
import 'api/psd.dart';
import 'api/selection_path.dart';
import 'api/simple.dart';
import 'api/workspace.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -1237602523;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'rust_lib_misa_rin',
        ioDirectory: 'rust/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  BigInt crateApiMemoryAllocatePixelBuffer({required int size});

  Uint8List crateApiImageOpsConvertPixelsToRgba({required List<int> pixels});

  CpuBlendResult crateApiCpuBlendCpuBlendOnCanvasRgba({
    required List<int> src,
    required List<int> dst,
    required int width,
    required int height,
    required int startX,
    required int endX,
    required int startY,
    required int endY,
    required double opacity,
    required int blendMode,
    Uint32List? mask,
    required double maskOpacity,
  });

  CpuBlendOverflowResult crateApiCpuBlendCpuBlendOverflowRgba({
    required List<int> canvas,
    required int width,
    required int height,
    required List<int> upperX,
    required List<int> upperY,
    required List<int> upperColor,
    required List<int> lowerX,
    required List<int> lowerY,
    required List<int> lowerColor,
    required double opacity,
    required int blendMode,
    Uint32List? mask,
    required double maskOpacity,
    required List<int> maskOverflowX,
    required List<int> maskOverflowY,
    required List<int> maskOverflowColor,
    required BigInt outCapacity,
  });

  CpuBrushResult crateApiCpuBrushCpuBrushApplyCommandsRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required List<CpuBrushCommand> commands,
    Uint8List? selection,
  });

  CpuStreamlineResult crateApiCpuBrushCpuBrushApplyStreamlineSamples({
    required List<double> samples,
    required double strength,
  });

  CpuBrushResult crateApiCpuBrushCpuBrushDrawCapsuleSegmentRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required double ax,
    required double ay,
    required double bx,
    required double by,
    required double startRadius,
    required double endRadius,
    required int colorArgb,
    required int antialiasLevel,
    required bool includeStartCap,
    required bool erase,
    required bool screentoneEnabled,
    required double screentoneSpacing,
    required double screentoneDotSize,
    required double screentoneRotation,
    required double screentoneSoftness,
    Uint8List? selection,
  });

  CpuBrushResult crateApiCpuBrushCpuBrushDrawSprayRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required List<double> points,
    required int colorArgb,
    required int brushShape,
    required int antialiasLevel,
    required double softness,
    required bool erase,
    required bool accumulate,
    Uint8List? selection,
  });

  CpuBrushResult crateApiCpuBrushCpuBrushDrawStampRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required double centerX,
    required double centerY,
    required double radius,
    required int colorArgb,
    required int brushShape,
    required int antialiasLevel,
    required double softness,
    required bool erase,
    required bool randomRotation,
    required bool smoothRotation,
    required int rotationSeed,
    required double rotationJitter,
    required bool screentoneEnabled,
    required double screentoneSpacing,
    required double screentoneDotSize,
    required double screentoneRotation,
    required double screentoneSoftness,
    required bool snapToPixel,
    Uint8List? selection,
  });

  CpuBrushResult crateApiCpuBrushCpuBrushDrawStampSegmentRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required double startX,
    required double startY,
    required double endX,
    required double endY,
    required double startRadius,
    required double endRadius,
    required int colorArgb,
    required int brushShape,
    required int antialiasLevel,
    required bool includeStart,
    required bool erase,
    required bool randomRotation,
    required bool smoothRotation,
    required int rotationSeed,
    required double rotationJitter,
    required bool screentoneEnabled,
    required double screentoneSpacing,
    required double screentoneDotSize,
    required double screentoneRotation,
    required double screentoneSoftness,
    required double spacing,
    required double scatter,
    required double softness,
    required bool snapToPixel,
    required bool accumulate,
    Uint8List? selection,
  });

  CpuBrushResult crateApiCpuBrushCpuBrushFillPolygonRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required List<double> vertices,
    required double radius,
    required int colorArgb,
    required int antialiasLevel,
    required double softness,
    required bool erase,
    Uint8List? selection,
  });

  Future<Uint32List> crateApiGpuCompositeCpuCompositeLayers({
    required List<GpuLayerData> layers,
    required int width,
    required int height,
  });

  CpuFiltersResult crateApiCpuFiltersCpuFiltersApplyAntialiasRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required int level,
    required bool previewOnly,
  });

  CpuFiltersBytesResult crateApiCpuFiltersCpuFiltersApplyFilterRgbaBytes({
    required List<int> pixels,
    required int width,
    required int height,
    required int filterType,
    required double param0,
    required double param1,
    required double param2,
    required double param3,
  });

  CpuImageBoundsResult crateApiCpuImageCpuImageBoundsRgba({
    required List<int> pixels,
    required int width,
    required int height,
  });

  CpuTransformSnapshotResult
  crateApiCpuTransformCpuTransformBuildOverflowSnapshot({
    required List<int> canvas,
    required int canvasWidth,
    required int canvasHeight,
    required int snapshotWidth,
    required int snapshotHeight,
    required int originX,
    required int originY,
    required List<int> overflowX,
    required List<int> overflowY,
    required List<int> overflowColor,
  });

  CpuTransformTranslateResult crateApiCpuTransformCpuTransformTranslateLayer({
    required List<int> canvas,
    required int canvasWidth,
    required int canvasHeight,
    required List<int> snapshot,
    required int snapshotWidth,
    required int snapshotHeight,
    required int originX,
    required int originY,
    required int dx,
    required int dy,
    required BigInt overflowCapacity,
  });

  Future<FloodFillRect> crateApiBucketFillFloodFillInPlace({
    required BigInt ptr,
    required int width,
    required int height,
    Uint32List? samplePixels,
    required int startX,
    required int startY,
    required int colorValue,
    int? targetColorValue,
    required bool contiguous,
    required int tolerance,
    required int fillGap,
    Uint8List? selectionMask,
    Uint32List? swallowColors,
    required int antialiasLevel,
  });

  Future<FloodFillPatch> crateApiBucketFillFloodFillPatch({
    required int width,
    required int height,
    required List<int> pixels,
    Uint32List? samplePixels,
    required int startX,
    required int startY,
    required int colorValue,
    int? targetColorValue,
    required bool contiguous,
    required int tolerance,
    required int fillGap,
    Uint8List? selectionMask,
    Uint32List? swallowColors,
    required int antialiasLevel,
  });

  void crateApiMemoryFreePixelBuffer({required BigInt ptr, required int size});

  void crateApiGpuBrushGpuBrushDispose();

  void crateApiGpuBrushGpuBrushInit();

  Future<Uint32List> crateApiGpuCompositeGpuCompositeLayers({
    required List<GpuLayerData> layers,
    required int width,
    required int height,
  });

  void crateApiGpuCompositeGpuCompositorDispose();

  void crateApiGpuCompositeGpuCompositorInit();

  Future<Uint32List> crateApiGpuBrushGpuDownloadLayer({
    required String layerId,
  });

  Future<GpuStrokeResult> crateApiGpuBrushGpuDrawStroke({
    required String layerId,
    required List<GpuPoint2D> points,
    required List<double> radii,
    required int color,
    required int brushShape,
    required bool erase,
    required int antialiasLevel,
  });

  void crateApiGpuBrushGpuRemoveLayer({required String layerId});

  Future<void> crateApiGpuBrushGpuUploadLayer({
    required String layerId,
    required List<int> pixels,
    required int width,
    required int height,
  });

  String crateApiSimpleGreet({required String name});

  Future<PsdDocument> crateApiPsdImportPsd({required List<int> bytes});

  Future<void> crateApiSimpleInitApp();

  Future<Uint8List?> crateApiBucketFillMagicWandMask({
    required int width,
    required int height,
    required List<int> pixels,
    required int startX,
    required int startY,
    required int tolerance,
    Uint8List? selectionMask,
  });

  int crateApiMemoryReadPixelAt({required BigInt ptr, required int index});

  Uint32List crateApiSelectionPathSelectionPathVerticesFromMask({
    required List<int> mask,
    required int width,
  });

  Future<WorkspaceEntry> crateApiWorkspaceWorkspaceEntryDefault();

  WorkspaceState crateApiWorkspaceWorkspaceMarkDirty({
    required String id,
    required bool isDirty,
  });

  WorkspaceEntry? crateApiWorkspaceWorkspaceNeighbor({required String id});

  WorkspaceState crateApiWorkspaceWorkspaceOpen({
    required WorkspaceEntry entry,
    required bool activate,
  });

  WorkspaceState crateApiWorkspaceWorkspaceRemove({
    required String id,
    String? activateAfter,
  });

  WorkspaceState crateApiWorkspaceWorkspaceReorder({
    required int oldIndex,
    required int newIndex,
  });

  WorkspaceState crateApiWorkspaceWorkspaceReset();

  WorkspaceState crateApiWorkspaceWorkspaceSetActive({required String id});

  WorkspaceState crateApiWorkspaceWorkspaceState();

  Future<WorkspaceState> crateApiWorkspaceWorkspaceStateDefault();
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  BigInt crateApiMemoryAllocatePixelBuffer({required int size}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(size, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_usize,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMemoryAllocatePixelBufferConstMeta,
        argValues: [size],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMemoryAllocatePixelBufferConstMeta =>
      const TaskConstMeta(
        debugName: "allocate_pixel_buffer",
        argNames: ["size"],
      );

  @override
  Uint8List crateApiImageOpsConvertPixelsToRgba({required List<int> pixels}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiImageOpsConvertPixelsToRgbaConstMeta,
        argValues: [pixels],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiImageOpsConvertPixelsToRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "convert_pixels_to_rgba",
        argNames: ["pixels"],
      );

  @override
  CpuBlendResult crateApiCpuBlendCpuBlendOnCanvasRgba({
    required List<int> src,
    required List<int> dst,
    required int width,
    required int height,
    required int startX,
    required int endX,
    required int startY,
    required int endY,
    required double opacity,
    required int blendMode,
    Uint32List? mask,
    required double maskOpacity,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(src, serializer);
          sse_encode_list_prim_u_32_loose(dst, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          sse_encode_i_32(startX, serializer);
          sse_encode_i_32(endX, serializer);
          sse_encode_i_32(startY, serializer);
          sse_encode_i_32(endY, serializer);
          sse_encode_f_32(opacity, serializer);
          sse_encode_u_32(blendMode, serializer);
          sse_encode_opt_list_prim_u_32_strict(mask, serializer);
          sse_encode_f_32(maskOpacity, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_blend_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuBlendCpuBlendOnCanvasRgbaConstMeta,
        argValues: [
          src,
          dst,
          width,
          height,
          startX,
          endX,
          startY,
          endY,
          opacity,
          blendMode,
          mask,
          maskOpacity,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuBlendCpuBlendOnCanvasRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_blend_on_canvas_rgba",
        argNames: [
          "src",
          "dst",
          "width",
          "height",
          "startX",
          "endX",
          "startY",
          "endY",
          "opacity",
          "blendMode",
          "mask",
          "maskOpacity",
        ],
      );

  @override
  CpuBlendOverflowResult crateApiCpuBlendCpuBlendOverflowRgba({
    required List<int> canvas,
    required int width,
    required int height,
    required List<int> upperX,
    required List<int> upperY,
    required List<int> upperColor,
    required List<int> lowerX,
    required List<int> lowerY,
    required List<int> lowerColor,
    required double opacity,
    required int blendMode,
    Uint32List? mask,
    required double maskOpacity,
    required List<int> maskOverflowX,
    required List<int> maskOverflowY,
    required List<int> maskOverflowColor,
    required BigInt outCapacity,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(canvas, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          sse_encode_list_prim_i_32_loose(upperX, serializer);
          sse_encode_list_prim_i_32_loose(upperY, serializer);
          sse_encode_list_prim_u_32_loose(upperColor, serializer);
          sse_encode_list_prim_i_32_loose(lowerX, serializer);
          sse_encode_list_prim_i_32_loose(lowerY, serializer);
          sse_encode_list_prim_u_32_loose(lowerColor, serializer);
          sse_encode_f_32(opacity, serializer);
          sse_encode_u_32(blendMode, serializer);
          sse_encode_opt_list_prim_u_32_strict(mask, serializer);
          sse_encode_f_32(maskOpacity, serializer);
          sse_encode_list_prim_i_32_loose(maskOverflowX, serializer);
          sse_encode_list_prim_i_32_loose(maskOverflowY, serializer);
          sse_encode_list_prim_u_32_loose(maskOverflowColor, serializer);
          sse_encode_u_64(outCapacity, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_blend_overflow_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuBlendCpuBlendOverflowRgbaConstMeta,
        argValues: [
          canvas,
          width,
          height,
          upperX,
          upperY,
          upperColor,
          lowerX,
          lowerY,
          lowerColor,
          opacity,
          blendMode,
          mask,
          maskOpacity,
          maskOverflowX,
          maskOverflowY,
          maskOverflowColor,
          outCapacity,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuBlendCpuBlendOverflowRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_blend_overflow_rgba",
        argNames: [
          "canvas",
          "width",
          "height",
          "upperX",
          "upperY",
          "upperColor",
          "lowerX",
          "lowerY",
          "lowerColor",
          "opacity",
          "blendMode",
          "mask",
          "maskOpacity",
          "maskOverflowX",
          "maskOverflowY",
          "maskOverflowColor",
          "outCapacity",
        ],
      );

  @override
  CpuBrushResult crateApiCpuBrushCpuBrushApplyCommandsRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required List<CpuBrushCommand> commands,
    Uint8List? selection,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          sse_encode_list_cpu_brush_command(commands, serializer);
          sse_encode_opt_list_prim_u_8_strict(selection, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_brush_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuBrushCpuBrushApplyCommandsRgbaConstMeta,
        argValues: [pixels, width, height, commands, selection],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuBrushCpuBrushApplyCommandsRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_brush_apply_commands_rgba",
        argNames: ["pixels", "width", "height", "commands", "selection"],
      );

  @override
  CpuStreamlineResult crateApiCpuBrushCpuBrushApplyStreamlineSamples({
    required List<double> samples,
    required double strength,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_f_32_loose(samples, serializer);
          sse_encode_f_32(strength, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_streamline_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuBrushCpuBrushApplyStreamlineSamplesConstMeta,
        argValues: [samples, strength],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuBrushCpuBrushApplyStreamlineSamplesConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_brush_apply_streamline_samples",
        argNames: ["samples", "strength"],
      );

  @override
  CpuBrushResult crateApiCpuBrushCpuBrushDrawCapsuleSegmentRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required double ax,
    required double ay,
    required double bx,
    required double by,
    required double startRadius,
    required double endRadius,
    required int colorArgb,
    required int antialiasLevel,
    required bool includeStartCap,
    required bool erase,
    required bool screentoneEnabled,
    required double screentoneSpacing,
    required double screentoneDotSize,
    required double screentoneRotation,
    required double screentoneSoftness,
    Uint8List? selection,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          sse_encode_f_32(ax, serializer);
          sse_encode_f_32(ay, serializer);
          sse_encode_f_32(bx, serializer);
          sse_encode_f_32(by, serializer);
          sse_encode_f_32(startRadius, serializer);
          sse_encode_f_32(endRadius, serializer);
          sse_encode_u_32(colorArgb, serializer);
          sse_encode_u_32(antialiasLevel, serializer);
          sse_encode_bool(includeStartCap, serializer);
          sse_encode_bool(erase, serializer);
          sse_encode_bool(screentoneEnabled, serializer);
          sse_encode_f_32(screentoneSpacing, serializer);
          sse_encode_f_32(screentoneDotSize, serializer);
          sse_encode_f_32(screentoneRotation, serializer);
          sse_encode_f_32(screentoneSoftness, serializer);
          sse_encode_opt_list_prim_u_8_strict(selection, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_brush_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuBrushCpuBrushDrawCapsuleSegmentRgbaConstMeta,
        argValues: [
          pixels,
          width,
          height,
          ax,
          ay,
          bx,
          by,
          startRadius,
          endRadius,
          colorArgb,
          antialiasLevel,
          includeStartCap,
          erase,
          screentoneEnabled,
          screentoneSpacing,
          screentoneDotSize,
          screentoneRotation,
          screentoneSoftness,
          selection,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuBrushCpuBrushDrawCapsuleSegmentRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_brush_draw_capsule_segment_rgba",
        argNames: [
          "pixels",
          "width",
          "height",
          "ax",
          "ay",
          "bx",
          "by",
          "startRadius",
          "endRadius",
          "colorArgb",
          "antialiasLevel",
          "includeStartCap",
          "erase",
          "screentoneEnabled",
          "screentoneSpacing",
          "screentoneDotSize",
          "screentoneRotation",
          "screentoneSoftness",
          "selection",
        ],
      );

  @override
  CpuBrushResult crateApiCpuBrushCpuBrushDrawSprayRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required List<double> points,
    required int colorArgb,
    required int brushShape,
    required int antialiasLevel,
    required double softness,
    required bool erase,
    required bool accumulate,
    Uint8List? selection,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          sse_encode_list_prim_f_32_loose(points, serializer);
          sse_encode_u_32(colorArgb, serializer);
          sse_encode_u_32(brushShape, serializer);
          sse_encode_u_32(antialiasLevel, serializer);
          sse_encode_f_32(softness, serializer);
          sse_encode_bool(erase, serializer);
          sse_encode_bool(accumulate, serializer);
          sse_encode_opt_list_prim_u_8_strict(selection, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_brush_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuBrushCpuBrushDrawSprayRgbaConstMeta,
        argValues: [
          pixels,
          width,
          height,
          points,
          colorArgb,
          brushShape,
          antialiasLevel,
          softness,
          erase,
          accumulate,
          selection,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuBrushCpuBrushDrawSprayRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_brush_draw_spray_rgba",
        argNames: [
          "pixels",
          "width",
          "height",
          "points",
          "colorArgb",
          "brushShape",
          "antialiasLevel",
          "softness",
          "erase",
          "accumulate",
          "selection",
        ],
      );

  @override
  CpuBrushResult crateApiCpuBrushCpuBrushDrawStampRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required double centerX,
    required double centerY,
    required double radius,
    required int colorArgb,
    required int brushShape,
    required int antialiasLevel,
    required double softness,
    required bool erase,
    required bool randomRotation,
    required bool smoothRotation,
    required int rotationSeed,
    required double rotationJitter,
    required bool screentoneEnabled,
    required double screentoneSpacing,
    required double screentoneDotSize,
    required double screentoneRotation,
    required double screentoneSoftness,
    required bool snapToPixel,
    Uint8List? selection,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          sse_encode_f_32(centerX, serializer);
          sse_encode_f_32(centerY, serializer);
          sse_encode_f_32(radius, serializer);
          sse_encode_u_32(colorArgb, serializer);
          sse_encode_u_32(brushShape, serializer);
          sse_encode_u_32(antialiasLevel, serializer);
          sse_encode_f_32(softness, serializer);
          sse_encode_bool(erase, serializer);
          sse_encode_bool(randomRotation, serializer);
          sse_encode_bool(smoothRotation, serializer);
          sse_encode_u_32(rotationSeed, serializer);
          sse_encode_f_32(rotationJitter, serializer);
          sse_encode_bool(screentoneEnabled, serializer);
          sse_encode_f_32(screentoneSpacing, serializer);
          sse_encode_f_32(screentoneDotSize, serializer);
          sse_encode_f_32(screentoneRotation, serializer);
          sse_encode_f_32(screentoneSoftness, serializer);
          sse_encode_bool(snapToPixel, serializer);
          sse_encode_opt_list_prim_u_8_strict(selection, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_brush_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuBrushCpuBrushDrawStampRgbaConstMeta,
        argValues: [
          pixels,
          width,
          height,
          centerX,
          centerY,
          radius,
          colorArgb,
          brushShape,
          antialiasLevel,
          softness,
          erase,
          randomRotation,
          smoothRotation,
          rotationSeed,
          rotationJitter,
          screentoneEnabled,
          screentoneSpacing,
          screentoneDotSize,
          screentoneRotation,
          screentoneSoftness,
          snapToPixel,
          selection,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuBrushCpuBrushDrawStampRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_brush_draw_stamp_rgba",
        argNames: [
          "pixels",
          "width",
          "height",
          "centerX",
          "centerY",
          "radius",
          "colorArgb",
          "brushShape",
          "antialiasLevel",
          "softness",
          "erase",
          "randomRotation",
          "smoothRotation",
          "rotationSeed",
          "rotationJitter",
          "screentoneEnabled",
          "screentoneSpacing",
          "screentoneDotSize",
          "screentoneRotation",
          "screentoneSoftness",
          "snapToPixel",
          "selection",
        ],
      );

  @override
  CpuBrushResult crateApiCpuBrushCpuBrushDrawStampSegmentRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required double startX,
    required double startY,
    required double endX,
    required double endY,
    required double startRadius,
    required double endRadius,
    required int colorArgb,
    required int brushShape,
    required int antialiasLevel,
    required bool includeStart,
    required bool erase,
    required bool randomRotation,
    required bool smoothRotation,
    required int rotationSeed,
    required double rotationJitter,
    required bool screentoneEnabled,
    required double screentoneSpacing,
    required double screentoneDotSize,
    required double screentoneRotation,
    required double screentoneSoftness,
    required double spacing,
    required double scatter,
    required double softness,
    required bool snapToPixel,
    required bool accumulate,
    Uint8List? selection,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          sse_encode_f_32(startX, serializer);
          sse_encode_f_32(startY, serializer);
          sse_encode_f_32(endX, serializer);
          sse_encode_f_32(endY, serializer);
          sse_encode_f_32(startRadius, serializer);
          sse_encode_f_32(endRadius, serializer);
          sse_encode_u_32(colorArgb, serializer);
          sse_encode_u_32(brushShape, serializer);
          sse_encode_u_32(antialiasLevel, serializer);
          sse_encode_bool(includeStart, serializer);
          sse_encode_bool(erase, serializer);
          sse_encode_bool(randomRotation, serializer);
          sse_encode_bool(smoothRotation, serializer);
          sse_encode_u_32(rotationSeed, serializer);
          sse_encode_f_32(rotationJitter, serializer);
          sse_encode_bool(screentoneEnabled, serializer);
          sse_encode_f_32(screentoneSpacing, serializer);
          sse_encode_f_32(screentoneDotSize, serializer);
          sse_encode_f_32(screentoneRotation, serializer);
          sse_encode_f_32(screentoneSoftness, serializer);
          sse_encode_f_32(spacing, serializer);
          sse_encode_f_32(scatter, serializer);
          sse_encode_f_32(softness, serializer);
          sse_encode_bool(snapToPixel, serializer);
          sse_encode_bool(accumulate, serializer);
          sse_encode_opt_list_prim_u_8_strict(selection, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_brush_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuBrushCpuBrushDrawStampSegmentRgbaConstMeta,
        argValues: [
          pixels,
          width,
          height,
          startX,
          startY,
          endX,
          endY,
          startRadius,
          endRadius,
          colorArgb,
          brushShape,
          antialiasLevel,
          includeStart,
          erase,
          randomRotation,
          smoothRotation,
          rotationSeed,
          rotationJitter,
          screentoneEnabled,
          screentoneSpacing,
          screentoneDotSize,
          screentoneRotation,
          screentoneSoftness,
          spacing,
          scatter,
          softness,
          snapToPixel,
          accumulate,
          selection,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuBrushCpuBrushDrawStampSegmentRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_brush_draw_stamp_segment_rgba",
        argNames: [
          "pixels",
          "width",
          "height",
          "startX",
          "startY",
          "endX",
          "endY",
          "startRadius",
          "endRadius",
          "colorArgb",
          "brushShape",
          "antialiasLevel",
          "includeStart",
          "erase",
          "randomRotation",
          "smoothRotation",
          "rotationSeed",
          "rotationJitter",
          "screentoneEnabled",
          "screentoneSpacing",
          "screentoneDotSize",
          "screentoneRotation",
          "screentoneSoftness",
          "spacing",
          "scatter",
          "softness",
          "snapToPixel",
          "accumulate",
          "selection",
        ],
      );

  @override
  CpuBrushResult crateApiCpuBrushCpuBrushFillPolygonRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required List<double> vertices,
    required double radius,
    required int colorArgb,
    required int antialiasLevel,
    required double softness,
    required bool erase,
    Uint8List? selection,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          sse_encode_list_prim_f_32_loose(vertices, serializer);
          sse_encode_f_32(radius, serializer);
          sse_encode_u_32(colorArgb, serializer);
          sse_encode_u_32(antialiasLevel, serializer);
          sse_encode_f_32(softness, serializer);
          sse_encode_bool(erase, serializer);
          sse_encode_opt_list_prim_u_8_strict(selection, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_brush_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuBrushCpuBrushFillPolygonRgbaConstMeta,
        argValues: [
          pixels,
          width,
          height,
          vertices,
          radius,
          colorArgb,
          antialiasLevel,
          softness,
          erase,
          selection,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuBrushCpuBrushFillPolygonRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_brush_fill_polygon_rgba",
        argNames: [
          "pixels",
          "width",
          "height",
          "vertices",
          "radius",
          "colorArgb",
          "antialiasLevel",
          "softness",
          "erase",
          "selection",
        ],
      );

  @override
  Future<Uint32List> crateApiGpuCompositeCpuCompositeLayers({
    required List<GpuLayerData> layers,
    required int width,
    required int height,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_gpu_layer_data(layers, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 12,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_32_strict,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuCompositeCpuCompositeLayersConstMeta,
        argValues: [layers, width, height],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuCompositeCpuCompositeLayersConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_composite_layers",
        argNames: ["layers", "width", "height"],
      );

  @override
  CpuFiltersResult crateApiCpuFiltersCpuFiltersApplyAntialiasRgba({
    required List<int> pixels,
    required int width,
    required int height,
    required int level,
    required bool previewOnly,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          sse_encode_u_32(level, serializer);
          sse_encode_bool(previewOnly, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 13)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_filters_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuFiltersCpuFiltersApplyAntialiasRgbaConstMeta,
        argValues: [pixels, width, height, level, previewOnly],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuFiltersCpuFiltersApplyAntialiasRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_filters_apply_antialias_rgba",
        argNames: ["pixels", "width", "height", "level", "previewOnly"],
      );

  @override
  CpuFiltersBytesResult crateApiCpuFiltersCpuFiltersApplyFilterRgbaBytes({
    required List<int> pixels,
    required int width,
    required int height,
    required int filterType,
    required double param0,
    required double param1,
    required double param2,
    required double param3,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          sse_encode_u_32(filterType, serializer);
          sse_encode_f_32(param0, serializer);
          sse_encode_f_32(param1, serializer);
          sse_encode_f_32(param2, serializer);
          sse_encode_f_32(param3, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_filters_bytes_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuFiltersCpuFiltersApplyFilterRgbaBytesConstMeta,
        argValues: [
          pixels,
          width,
          height,
          filterType,
          param0,
          param1,
          param2,
          param3,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiCpuFiltersCpuFiltersApplyFilterRgbaBytesConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_filters_apply_filter_rgba_bytes",
        argNames: [
          "pixels",
          "width",
          "height",
          "filterType",
          "param0",
          "param1",
          "param2",
          "param3",
        ],
      );

  @override
  CpuImageBoundsResult crateApiCpuImageCpuImageBoundsRgba({
    required List<int> pixels,
    required int width,
    required int height,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_image_bounds_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuImageCpuImageBoundsRgbaConstMeta,
        argValues: [pixels, width, height],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuImageCpuImageBoundsRgbaConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_image_bounds_rgba",
        argNames: ["pixels", "width", "height"],
      );

  @override
  CpuTransformSnapshotResult
  crateApiCpuTransformCpuTransformBuildOverflowSnapshot({
    required List<int> canvas,
    required int canvasWidth,
    required int canvasHeight,
    required int snapshotWidth,
    required int snapshotHeight,
    required int originX,
    required int originY,
    required List<int> overflowX,
    required List<int> overflowY,
    required List<int> overflowColor,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(canvas, serializer);
          sse_encode_u_32(canvasWidth, serializer);
          sse_encode_u_32(canvasHeight, serializer);
          sse_encode_u_32(snapshotWidth, serializer);
          sse_encode_u_32(snapshotHeight, serializer);
          sse_encode_i_32(originX, serializer);
          sse_encode_i_32(originY, serializer);
          sse_encode_list_prim_i_32_loose(overflowX, serializer);
          sse_encode_list_prim_i_32_loose(overflowY, serializer);
          sse_encode_list_prim_u_32_loose(overflowColor, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_transform_snapshot_result,
          decodeErrorData: null,
        ),
        constMeta:
            kCrateApiCpuTransformCpuTransformBuildOverflowSnapshotConstMeta,
        argValues: [
          canvas,
          canvasWidth,
          canvasHeight,
          snapshotWidth,
          snapshotHeight,
          originX,
          originY,
          overflowX,
          overflowY,
          overflowColor,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiCpuTransformCpuTransformBuildOverflowSnapshotConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_transform_build_overflow_snapshot",
        argNames: [
          "canvas",
          "canvasWidth",
          "canvasHeight",
          "snapshotWidth",
          "snapshotHeight",
          "originX",
          "originY",
          "overflowX",
          "overflowY",
          "overflowColor",
        ],
      );

  @override
  CpuTransformTranslateResult crateApiCpuTransformCpuTransformTranslateLayer({
    required List<int> canvas,
    required int canvasWidth,
    required int canvasHeight,
    required List<int> snapshot,
    required int snapshotWidth,
    required int snapshotHeight,
    required int originX,
    required int originY,
    required int dx,
    required int dy,
    required BigInt overflowCapacity,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_32_loose(canvas, serializer);
          sse_encode_u_32(canvasWidth, serializer);
          sse_encode_u_32(canvasHeight, serializer);
          sse_encode_list_prim_u_32_loose(snapshot, serializer);
          sse_encode_u_32(snapshotWidth, serializer);
          sse_encode_u_32(snapshotHeight, serializer);
          sse_encode_i_32(originX, serializer);
          sse_encode_i_32(originY, serializer);
          sse_encode_i_32(dx, serializer);
          sse_encode_i_32(dy, serializer);
          sse_encode_u_64(overflowCapacity, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_cpu_transform_translate_result,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiCpuTransformCpuTransformTranslateLayerConstMeta,
        argValues: [
          canvas,
          canvasWidth,
          canvasHeight,
          snapshot,
          snapshotWidth,
          snapshotHeight,
          originX,
          originY,
          dx,
          dy,
          overflowCapacity,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiCpuTransformCpuTransformTranslateLayerConstMeta =>
      const TaskConstMeta(
        debugName: "cpu_transform_translate_layer",
        argNames: [
          "canvas",
          "canvasWidth",
          "canvasHeight",
          "snapshot",
          "snapshotWidth",
          "snapshotHeight",
          "originX",
          "originY",
          "dx",
          "dy",
          "overflowCapacity",
        ],
      );

  @override
  Future<FloodFillRect> crateApiBucketFillFloodFillInPlace({
    required BigInt ptr,
    required int width,
    required int height,
    Uint32List? samplePixels,
    required int startX,
    required int startY,
    required int colorValue,
    int? targetColorValue,
    required bool contiguous,
    required int tolerance,
    required int fillGap,
    Uint8List? selectionMask,
    Uint32List? swallowColors,
    required int antialiasLevel,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_usize(ptr, serializer);
          sse_encode_i_32(width, serializer);
          sse_encode_i_32(height, serializer);
          sse_encode_opt_list_prim_u_32_strict(samplePixels, serializer);
          sse_encode_i_32(startX, serializer);
          sse_encode_i_32(startY, serializer);
          sse_encode_u_32(colorValue, serializer);
          sse_encode_opt_box_autoadd_u_32(targetColorValue, serializer);
          sse_encode_bool(contiguous, serializer);
          sse_encode_i_32(tolerance, serializer);
          sse_encode_i_32(fillGap, serializer);
          sse_encode_opt_list_prim_u_8_strict(selectionMask, serializer);
          sse_encode_opt_list_prim_u_32_strict(swallowColors, serializer);
          sse_encode_i_32(antialiasLevel, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 18,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_flood_fill_rect,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiBucketFillFloodFillInPlaceConstMeta,
        argValues: [
          ptr,
          width,
          height,
          samplePixels,
          startX,
          startY,
          colorValue,
          targetColorValue,
          contiguous,
          tolerance,
          fillGap,
          selectionMask,
          swallowColors,
          antialiasLevel,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBucketFillFloodFillInPlaceConstMeta =>
      const TaskConstMeta(
        debugName: "flood_fill_in_place",
        argNames: [
          "ptr",
          "width",
          "height",
          "samplePixels",
          "startX",
          "startY",
          "colorValue",
          "targetColorValue",
          "contiguous",
          "tolerance",
          "fillGap",
          "selectionMask",
          "swallowColors",
          "antialiasLevel",
        ],
      );

  @override
  Future<FloodFillPatch> crateApiBucketFillFloodFillPatch({
    required int width,
    required int height,
    required List<int> pixels,
    Uint32List? samplePixels,
    required int startX,
    required int startY,
    required int colorValue,
    int? targetColorValue,
    required bool contiguous,
    required int tolerance,
    required int fillGap,
    Uint8List? selectionMask,
    Uint32List? swallowColors,
    required int antialiasLevel,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(width, serializer);
          sse_encode_i_32(height, serializer);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_opt_list_prim_u_32_strict(samplePixels, serializer);
          sse_encode_i_32(startX, serializer);
          sse_encode_i_32(startY, serializer);
          sse_encode_u_32(colorValue, serializer);
          sse_encode_opt_box_autoadd_u_32(targetColorValue, serializer);
          sse_encode_bool(contiguous, serializer);
          sse_encode_i_32(tolerance, serializer);
          sse_encode_i_32(fillGap, serializer);
          sse_encode_opt_list_prim_u_8_strict(selectionMask, serializer);
          sse_encode_opt_list_prim_u_32_strict(swallowColors, serializer);
          sse_encode_i_32(antialiasLevel, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 19,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_flood_fill_patch,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiBucketFillFloodFillPatchConstMeta,
        argValues: [
          width,
          height,
          pixels,
          samplePixels,
          startX,
          startY,
          colorValue,
          targetColorValue,
          contiguous,
          tolerance,
          fillGap,
          selectionMask,
          swallowColors,
          antialiasLevel,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBucketFillFloodFillPatchConstMeta =>
      const TaskConstMeta(
        debugName: "flood_fill_patch",
        argNames: [
          "width",
          "height",
          "pixels",
          "samplePixels",
          "startX",
          "startY",
          "colorValue",
          "targetColorValue",
          "contiguous",
          "tolerance",
          "fillGap",
          "selectionMask",
          "swallowColors",
          "antialiasLevel",
        ],
      );

  @override
  void crateApiMemoryFreePixelBuffer({required BigInt ptr, required int size}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_usize(ptr, serializer);
          sse_encode_i_32(size, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMemoryFreePixelBufferConstMeta,
        argValues: [ptr, size],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMemoryFreePixelBufferConstMeta =>
      const TaskConstMeta(
        debugName: "free_pixel_buffer",
        argNames: ["ptr", "size"],
      );

  @override
  void crateApiGpuBrushGpuBrushDispose() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGpuBrushGpuBrushDisposeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuBrushDisposeConstMeta =>
      const TaskConstMeta(debugName: "gpu_brush_dispose", argNames: []);

  @override
  void crateApiGpuBrushGpuBrushInit() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuBrushGpuBrushInitConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuBrushInitConstMeta =>
      const TaskConstMeta(debugName: "gpu_brush_init", argNames: []);

  @override
  Future<Uint32List> crateApiGpuCompositeGpuCompositeLayers({
    required List<GpuLayerData> layers,
    required int width,
    required int height,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_gpu_layer_data(layers, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 23,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_32_strict,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuCompositeGpuCompositeLayersConstMeta,
        argValues: [layers, width, height],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuCompositeGpuCompositeLayersConstMeta =>
      const TaskConstMeta(
        debugName: "gpu_composite_layers",
        argNames: ["layers", "width", "height"],
      );

  @override
  void crateApiGpuCompositeGpuCompositorDispose() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiGpuCompositeGpuCompositorDisposeConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuCompositeGpuCompositorDisposeConstMeta =>
      const TaskConstMeta(debugName: "gpu_compositor_dispose", argNames: []);

  @override
  void crateApiGpuCompositeGpuCompositorInit() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuCompositeGpuCompositorInitConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuCompositeGpuCompositorInitConstMeta =>
      const TaskConstMeta(debugName: "gpu_compositor_init", argNames: []);

  @override
  Future<Uint32List> crateApiGpuBrushGpuDownloadLayer({
    required String layerId,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(layerId, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 26,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_32_strict,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuBrushGpuDownloadLayerConstMeta,
        argValues: [layerId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuDownloadLayerConstMeta =>
      const TaskConstMeta(
        debugName: "gpu_download_layer",
        argNames: ["layerId"],
      );

  @override
  Future<GpuStrokeResult> crateApiGpuBrushGpuDrawStroke({
    required String layerId,
    required List<GpuPoint2D> points,
    required List<double> radii,
    required int color,
    required int brushShape,
    required bool erase,
    required int antialiasLevel,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(layerId, serializer);
          sse_encode_list_gpu_point_2_d(points, serializer);
          sse_encode_list_prim_f_32_loose(radii, serializer);
          sse_encode_u_32(color, serializer);
          sse_encode_u_32(brushShape, serializer);
          sse_encode_bool(erase, serializer);
          sse_encode_u_32(antialiasLevel, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 27,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_gpu_stroke_result,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuBrushGpuDrawStrokeConstMeta,
        argValues: [
          layerId,
          points,
          radii,
          color,
          brushShape,
          erase,
          antialiasLevel,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuDrawStrokeConstMeta =>
      const TaskConstMeta(
        debugName: "gpu_draw_stroke",
        argNames: [
          "layerId",
          "points",
          "radii",
          "color",
          "brushShape",
          "erase",
          "antialiasLevel",
        ],
      );

  @override
  void crateApiGpuBrushGpuRemoveLayer({required String layerId}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(layerId, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuBrushGpuRemoveLayerConstMeta,
        argValues: [layerId],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuRemoveLayerConstMeta =>
      const TaskConstMeta(debugName: "gpu_remove_layer", argNames: ["layerId"]);

  @override
  Future<void> crateApiGpuBrushGpuUploadLayer({
    required String layerId,
    required List<int> pixels,
    required int width,
    required int height,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(layerId, serializer);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_u_32(width, serializer);
          sse_encode_u_32(height, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 29,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiGpuBrushGpuUploadLayerConstMeta,
        argValues: [layerId, pixels, width, height],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiGpuBrushGpuUploadLayerConstMeta =>
      const TaskConstMeta(
        debugName: "gpu_upload_layer",
        argNames: ["layerId", "pixels", "width", "height"],
      );

  @override
  String crateApiSimpleGreet({required String name}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(name, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_String,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSimpleGreetConstMeta,
        argValues: [name],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSimpleGreetConstMeta =>
      const TaskConstMeta(debugName: "greet", argNames: ["name"]);

  @override
  Future<PsdDocument> crateApiPsdImportPsd({required List<int> bytes}) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(bytes, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 31,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_psd_document,
          decodeErrorData: sse_decode_String,
        ),
        constMeta: kCrateApiPsdImportPsdConstMeta,
        argValues: [bytes],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiPsdImportPsdConstMeta =>
      const TaskConstMeta(debugName: "import_psd", argNames: ["bytes"]);

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 32,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSimpleInitAppConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta =>
      const TaskConstMeta(debugName: "init_app", argNames: []);

  @override
  Future<Uint8List?> crateApiBucketFillMagicWandMask({
    required int width,
    required int height,
    required List<int> pixels,
    required int startX,
    required int startY,
    required int tolerance,
    Uint8List? selectionMask,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(width, serializer);
          sse_encode_i_32(height, serializer);
          sse_encode_list_prim_u_32_loose(pixels, serializer);
          sse_encode_i_32(startX, serializer);
          sse_encode_i_32(startY, serializer);
          sse_encode_i_32(tolerance, serializer);
          sse_encode_opt_list_prim_u_8_strict(selectionMask, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 33,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_list_prim_u_8_strict,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiBucketFillMagicWandMaskConstMeta,
        argValues: [
          width,
          height,
          pixels,
          startX,
          startY,
          tolerance,
          selectionMask,
        ],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiBucketFillMagicWandMaskConstMeta =>
      const TaskConstMeta(
        debugName: "magic_wand_mask",
        argNames: [
          "width",
          "height",
          "pixels",
          "startX",
          "startY",
          "tolerance",
          "selectionMask",
        ],
      );

  @override
  int crateApiMemoryReadPixelAt({required BigInt ptr, required int index}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_usize(ptr, serializer);
          sse_encode_i_32(index, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_32,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiMemoryReadPixelAtConstMeta,
        argValues: [ptr, index],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiMemoryReadPixelAtConstMeta => const TaskConstMeta(
    debugName: "read_pixel_at",
    argNames: ["ptr", "index"],
  );

  @override
  Uint32List crateApiSelectionPathSelectionPathVerticesFromMask({
    required List<int> mask,
    required int width,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_prim_u_8_loose(mask, serializer);
          sse_encode_i_32(width, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_list_prim_u_32_strict,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiSelectionPathSelectionPathVerticesFromMaskConstMeta,
        argValues: [mask, width],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateApiSelectionPathSelectionPathVerticesFromMaskConstMeta =>
      const TaskConstMeta(
        debugName: "selection_path_vertices_from_mask",
        argNames: ["mask", "width"],
      );

  @override
  Future<WorkspaceEntry> crateApiWorkspaceWorkspaceEntryDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 36,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_workspace_entry,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWorkspaceWorkspaceEntryDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWorkspaceWorkspaceEntryDefaultConstMeta =>
      const TaskConstMeta(debugName: "workspace_entry_default", argNames: []);

  @override
  WorkspaceState crateApiWorkspaceWorkspaceMarkDirty({
    required String id,
    required bool isDirty,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(id, serializer);
          sse_encode_bool(isDirty, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_workspace_state,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWorkspaceWorkspaceMarkDirtyConstMeta,
        argValues: [id, isDirty],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWorkspaceWorkspaceMarkDirtyConstMeta =>
      const TaskConstMeta(
        debugName: "workspace_mark_dirty",
        argNames: ["id", "isDirty"],
      );

  @override
  WorkspaceEntry? crateApiWorkspaceWorkspaceNeighbor({required String id}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(id, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_opt_box_autoadd_workspace_entry,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWorkspaceWorkspaceNeighborConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWorkspaceWorkspaceNeighborConstMeta =>
      const TaskConstMeta(debugName: "workspace_neighbor", argNames: ["id"]);

  @override
  WorkspaceState crateApiWorkspaceWorkspaceOpen({
    required WorkspaceEntry entry,
    required bool activate,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_workspace_entry(entry, serializer);
          sse_encode_bool(activate, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_workspace_state,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWorkspaceWorkspaceOpenConstMeta,
        argValues: [entry, activate],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWorkspaceWorkspaceOpenConstMeta =>
      const TaskConstMeta(
        debugName: "workspace_open",
        argNames: ["entry", "activate"],
      );

  @override
  WorkspaceState crateApiWorkspaceWorkspaceRemove({
    required String id,
    String? activateAfter,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(id, serializer);
          sse_encode_opt_String(activateAfter, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_workspace_state,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWorkspaceWorkspaceRemoveConstMeta,
        argValues: [id, activateAfter],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWorkspaceWorkspaceRemoveConstMeta =>
      const TaskConstMeta(
        debugName: "workspace_remove",
        argNames: ["id", "activateAfter"],
      );

  @override
  WorkspaceState crateApiWorkspaceWorkspaceReorder({
    required int oldIndex,
    required int newIndex,
  }) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_i_32(oldIndex, serializer);
          sse_encode_i_32(newIndex, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_workspace_state,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWorkspaceWorkspaceReorderConstMeta,
        argValues: [oldIndex, newIndex],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWorkspaceWorkspaceReorderConstMeta =>
      const TaskConstMeta(
        debugName: "workspace_reorder",
        argNames: ["oldIndex", "newIndex"],
      );

  @override
  WorkspaceState crateApiWorkspaceWorkspaceReset() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_workspace_state,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWorkspaceWorkspaceResetConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWorkspaceWorkspaceResetConstMeta =>
      const TaskConstMeta(debugName: "workspace_reset", argNames: []);

  @override
  WorkspaceState crateApiWorkspaceWorkspaceSetActive({required String id}) {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_String(id, serializer);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_workspace_state,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWorkspaceWorkspaceSetActiveConstMeta,
        argValues: [id],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWorkspaceWorkspaceSetActiveConstMeta =>
      const TaskConstMeta(debugName: "workspace_set_active", argNames: ["id"]);

  @override
  WorkspaceState crateApiWorkspaceWorkspaceState() {
    return handler.executeSync(
      SyncTask(
        callFfi: () {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44)!;
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_workspace_state,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWorkspaceWorkspaceStateConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWorkspaceWorkspaceStateConstMeta =>
      const TaskConstMeta(debugName: "workspace_state", argNames: []);

  @override
  Future<WorkspaceState> crateApiWorkspaceWorkspaceStateDefault() {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 45,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_workspace_state,
          decodeErrorData: null,
        ),
        constMeta: kCrateApiWorkspaceWorkspaceStateDefaultConstMeta,
        argValues: [],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateApiWorkspaceWorkspaceStateDefaultConstMeta =>
      const TaskConstMeta(debugName: "workspace_state_default", argNames: []);

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  WorkspaceEntry dco_decode_box_autoadd_workspace_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_workspace_entry(raw);
  }

  @protected
  CpuBlendOverflowResult dco_decode_cpu_blend_overflow_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return CpuBlendOverflowResult(
      ok: dco_decode_bool(arr[0]),
      canvas: dco_decode_list_prim_u_32_strict(arr[1]),
      outX: dco_decode_list_prim_i_32_strict(arr[2]),
      outY: dco_decode_list_prim_i_32_strict(arr[3]),
      outColor: dco_decode_list_prim_u_32_strict(arr[4]),
    );
  }

  @protected
  CpuBlendResult dco_decode_cpu_blend_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return CpuBlendResult(
      ok: dco_decode_bool(arr[0]),
      canvas: dco_decode_list_prim_u_32_strict(arr[1]),
    );
  }

  @protected
  CpuBrushCommand dco_decode_cpu_brush_command(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 29)
      throw Exception('unexpected arr length: expect 29 but see ${arr.length}');
    return CpuBrushCommand(
      kind: dco_decode_u_32(arr[0]),
      ax: dco_decode_f_32(arr[1]),
      ay: dco_decode_f_32(arr[2]),
      bx: dco_decode_f_32(arr[3]),
      by: dco_decode_f_32(arr[4]),
      startRadius: dco_decode_f_32(arr[5]),
      endRadius: dco_decode_f_32(arr[6]),
      centerX: dco_decode_f_32(arr[7]),
      centerY: dco_decode_f_32(arr[8]),
      radius: dco_decode_f_32(arr[9]),
      colorArgb: dco_decode_u_32(arr[10]),
      brushShape: dco_decode_u_32(arr[11]),
      antialiasLevel: dco_decode_u_32(arr[12]),
      softness: dco_decode_f_32(arr[13]),
      erase: dco_decode_bool(arr[14]),
      includeStartCap: dco_decode_bool(arr[15]),
      includeStart: dco_decode_bool(arr[16]),
      randomRotation: dco_decode_bool(arr[17]),
      smoothRotation: dco_decode_bool(arr[18]),
      rotationSeed: dco_decode_u_32(arr[19]),
      rotationJitter: dco_decode_f_32(arr[20]),
      spacing: dco_decode_f_32(arr[21]),
      scatter: dco_decode_f_32(arr[22]),
      screentoneEnabled: dco_decode_bool(arr[23]),
      screentoneSpacing: dco_decode_f_32(arr[24]),
      screentoneDotSize: dco_decode_f_32(arr[25]),
      screentoneRotation: dco_decode_f_32(arr[26]),
      screentoneSoftness: dco_decode_f_32(arr[27]),
      snapToPixel: dco_decode_bool(arr[28]),
    );
  }

  @protected
  CpuBrushResult dco_decode_cpu_brush_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return CpuBrushResult(
      ok: dco_decode_bool(arr[0]),
      pixels: dco_decode_list_prim_u_32_strict(arr[1]),
    );
  }

  @protected
  CpuFiltersBytesResult dco_decode_cpu_filters_bytes_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return CpuFiltersBytesResult(
      ok: dco_decode_bool(arr[0]),
      pixels: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  CpuFiltersResult dco_decode_cpu_filters_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return CpuFiltersResult(
      ok: dco_decode_bool(arr[0]),
      pixels: dco_decode_list_prim_u_32_strict(arr[1]),
    );
  }

  @protected
  CpuImageBoundsResult dco_decode_cpu_image_bounds_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return CpuImageBoundsResult(
      ok: dco_decode_bool(arr[0]),
      bounds: dco_decode_list_prim_i_32_strict(arr[1]),
    );
  }

  @protected
  CpuStreamlineResult dco_decode_cpu_streamline_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return CpuStreamlineResult(
      ok: dco_decode_bool(arr[0]),
      samples: dco_decode_list_prim_f_32_strict(arr[1]),
    );
  }

  @protected
  CpuTransformSnapshotResult dco_decode_cpu_transform_snapshot_result(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return CpuTransformSnapshotResult(
      ok: dco_decode_bool(arr[0]),
      snapshot: dco_decode_list_prim_u_32_strict(arr[1]),
    );
  }

  @protected
  CpuTransformTranslateResult dco_decode_cpu_transform_translate_result(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return CpuTransformTranslateResult(
      ok: dco_decode_bool(arr[0]),
      canvas: dco_decode_list_prim_u_32_strict(arr[1]),
      overflowX: dco_decode_list_prim_i_32_strict(arr[2]),
      overflowY: dco_decode_list_prim_i_32_strict(arr[3]),
      overflowColor: dco_decode_list_prim_u_32_strict(arr[4]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FloodFillPatch dco_decode_flood_fill_patch(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return FloodFillPatch(
      left: dco_decode_i_32(arr[0]),
      top: dco_decode_i_32(arr[1]),
      width: dco_decode_i_32(arr[2]),
      height: dco_decode_i_32(arr[3]),
      pixels: dco_decode_list_prim_u_32_strict(arr[4]),
    );
  }

  @protected
  FloodFillRect dco_decode_flood_fill_rect(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return FloodFillRect(
      left: dco_decode_i_32(arr[0]),
      top: dco_decode_i_32(arr[1]),
      width: dco_decode_i_32(arr[2]),
      height: dco_decode_i_32(arr[3]),
    );
  }

  @protected
  GpuLayerData dco_decode_gpu_layer_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return GpuLayerData(
      pixels: dco_decode_list_prim_u_32_strict(arr[0]),
      opacity: dco_decode_f_64(arr[1]),
      blendModeIndex: dco_decode_u_32(arr[2]),
      visible: dco_decode_bool(arr[3]),
      clippingMask: dco_decode_bool(arr[4]),
    );
  }

  @protected
  GpuPoint2D dco_decode_gpu_point_2_d(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GpuPoint2D(x: dco_decode_f_32(arr[0]), y: dco_decode_f_32(arr[1]));
  }

  @protected
  GpuStrokeResult dco_decode_gpu_stroke_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return GpuStrokeResult(
      dirtyLeft: dco_decode_i_32(arr[0]),
      dirtyTop: dco_decode_i_32(arr[1]),
      dirtyWidth: dco_decode_i_32(arr[2]),
      dirtyHeight: dco_decode_i_32(arr[3]),
      drawCalls: dco_decode_u_32(arr[4]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<CpuBrushCommand> dco_decode_list_cpu_brush_command(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_cpu_brush_command).toList();
  }

  @protected
  List<GpuLayerData> dco_decode_list_gpu_layer_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_gpu_layer_data).toList();
  }

  @protected
  List<GpuPoint2D> dco_decode_list_gpu_point_2_d(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_gpu_point_2_d).toList();
  }

  @protected
  List<double> dco_decode_list_prim_f_32_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<double>;
  }

  @protected
  Float32List dco_decode_list_prim_f_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Float32List;
  }

  @protected
  List<int> dco_decode_list_prim_i_32_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Int32List dco_decode_list_prim_i_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Int32List;
  }

  @protected
  List<int> dco_decode_list_prim_u_32_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint32List dco_decode_list_prim_u_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint32List;
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<PsdLayer> dco_decode_list_psd_layer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_psd_layer).toList();
  }

  @protected
  List<WorkspaceEntry> dco_decode_list_workspace_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_workspace_entry).toList();
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  WorkspaceEntry? dco_decode_opt_box_autoadd_workspace_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_workspace_entry(raw);
  }

  @protected
  Uint32List? dco_decode_opt_list_prim_u_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_32_strict(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  PsdDocument dco_decode_psd_document(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PsdDocument(
      width: dco_decode_i_32(arr[0]),
      height: dco_decode_i_32(arr[1]),
      layers: dco_decode_list_psd_layer(arr[2]),
    );
  }

  @protected
  PsdLayer dco_decode_psd_layer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return PsdLayer(
      name: dco_decode_String(arr[0]),
      visible: dco_decode_bool(arr[1]),
      opacity: dco_decode_u_8(arr[2]),
      clippingMask: dco_decode_bool(arr[3]),
      blendModeKey: dco_decode_String(arr[4]),
      bitmap: dco_decode_list_prim_u_8_strict(arr[5]),
      bitmapWidth: dco_decode_i_32(arr[6]),
      bitmapHeight: dco_decode_i_32(arr[7]),
      bitmapLeft: dco_decode_i_32(arr[8]),
      bitmapTop: dco_decode_i_32(arr[9]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WorkspaceEntry dco_decode_workspace_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WorkspaceEntry(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      isDirty: dco_decode_bool(arr[2]),
    );
  }

  @protected
  WorkspaceState dco_decode_workspace_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return WorkspaceState(
      entries: dco_decode_list_workspace_entry(arr[0]),
      activeId: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  WorkspaceEntry sse_decode_box_autoadd_workspace_entry(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_workspace_entry(deserializer));
  }

  @protected
  CpuBlendOverflowResult sse_decode_cpu_blend_overflow_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ok = sse_decode_bool(deserializer);
    var var_canvas = sse_decode_list_prim_u_32_strict(deserializer);
    var var_outX = sse_decode_list_prim_i_32_strict(deserializer);
    var var_outY = sse_decode_list_prim_i_32_strict(deserializer);
    var var_outColor = sse_decode_list_prim_u_32_strict(deserializer);
    return CpuBlendOverflowResult(
      ok: var_ok,
      canvas: var_canvas,
      outX: var_outX,
      outY: var_outY,
      outColor: var_outColor,
    );
  }

  @protected
  CpuBlendResult sse_decode_cpu_blend_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ok = sse_decode_bool(deserializer);
    var var_canvas = sse_decode_list_prim_u_32_strict(deserializer);
    return CpuBlendResult(ok: var_ok, canvas: var_canvas);
  }

  @protected
  CpuBrushCommand sse_decode_cpu_brush_command(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_kind = sse_decode_u_32(deserializer);
    var var_ax = sse_decode_f_32(deserializer);
    var var_ay = sse_decode_f_32(deserializer);
    var var_bx = sse_decode_f_32(deserializer);
    var var_by = sse_decode_f_32(deserializer);
    var var_startRadius = sse_decode_f_32(deserializer);
    var var_endRadius = sse_decode_f_32(deserializer);
    var var_centerX = sse_decode_f_32(deserializer);
    var var_centerY = sse_decode_f_32(deserializer);
    var var_radius = sse_decode_f_32(deserializer);
    var var_colorArgb = sse_decode_u_32(deserializer);
    var var_brushShape = sse_decode_u_32(deserializer);
    var var_antialiasLevel = sse_decode_u_32(deserializer);
    var var_softness = sse_decode_f_32(deserializer);
    var var_erase = sse_decode_bool(deserializer);
    var var_includeStartCap = sse_decode_bool(deserializer);
    var var_includeStart = sse_decode_bool(deserializer);
    var var_randomRotation = sse_decode_bool(deserializer);
    var var_smoothRotation = sse_decode_bool(deserializer);
    var var_rotationSeed = sse_decode_u_32(deserializer);
    var var_rotationJitter = sse_decode_f_32(deserializer);
    var var_spacing = sse_decode_f_32(deserializer);
    var var_scatter = sse_decode_f_32(deserializer);
    var var_screentoneEnabled = sse_decode_bool(deserializer);
    var var_screentoneSpacing = sse_decode_f_32(deserializer);
    var var_screentoneDotSize = sse_decode_f_32(deserializer);
    var var_screentoneRotation = sse_decode_f_32(deserializer);
    var var_screentoneSoftness = sse_decode_f_32(deserializer);
    var var_snapToPixel = sse_decode_bool(deserializer);
    return CpuBrushCommand(
      kind: var_kind,
      ax: var_ax,
      ay: var_ay,
      bx: var_bx,
      by: var_by,
      startRadius: var_startRadius,
      endRadius: var_endRadius,
      centerX: var_centerX,
      centerY: var_centerY,
      radius: var_radius,
      colorArgb: var_colorArgb,
      brushShape: var_brushShape,
      antialiasLevel: var_antialiasLevel,
      softness: var_softness,
      erase: var_erase,
      includeStartCap: var_includeStartCap,
      includeStart: var_includeStart,
      randomRotation: var_randomRotation,
      smoothRotation: var_smoothRotation,
      rotationSeed: var_rotationSeed,
      rotationJitter: var_rotationJitter,
      spacing: var_spacing,
      scatter: var_scatter,
      screentoneEnabled: var_screentoneEnabled,
      screentoneSpacing: var_screentoneSpacing,
      screentoneDotSize: var_screentoneDotSize,
      screentoneRotation: var_screentoneRotation,
      screentoneSoftness: var_screentoneSoftness,
      snapToPixel: var_snapToPixel,
    );
  }

  @protected
  CpuBrushResult sse_decode_cpu_brush_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ok = sse_decode_bool(deserializer);
    var var_pixels = sse_decode_list_prim_u_32_strict(deserializer);
    return CpuBrushResult(ok: var_ok, pixels: var_pixels);
  }

  @protected
  CpuFiltersBytesResult sse_decode_cpu_filters_bytes_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ok = sse_decode_bool(deserializer);
    var var_pixels = sse_decode_list_prim_u_8_strict(deserializer);
    return CpuFiltersBytesResult(ok: var_ok, pixels: var_pixels);
  }

  @protected
  CpuFiltersResult sse_decode_cpu_filters_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ok = sse_decode_bool(deserializer);
    var var_pixels = sse_decode_list_prim_u_32_strict(deserializer);
    return CpuFiltersResult(ok: var_ok, pixels: var_pixels);
  }

  @protected
  CpuImageBoundsResult sse_decode_cpu_image_bounds_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ok = sse_decode_bool(deserializer);
    var var_bounds = sse_decode_list_prim_i_32_strict(deserializer);
    return CpuImageBoundsResult(ok: var_ok, bounds: var_bounds);
  }

  @protected
  CpuStreamlineResult sse_decode_cpu_streamline_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ok = sse_decode_bool(deserializer);
    var var_samples = sse_decode_list_prim_f_32_strict(deserializer);
    return CpuStreamlineResult(ok: var_ok, samples: var_samples);
  }

  @protected
  CpuTransformSnapshotResult sse_decode_cpu_transform_snapshot_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ok = sse_decode_bool(deserializer);
    var var_snapshot = sse_decode_list_prim_u_32_strict(deserializer);
    return CpuTransformSnapshotResult(ok: var_ok, snapshot: var_snapshot);
  }

  @protected
  CpuTransformTranslateResult sse_decode_cpu_transform_translate_result(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_ok = sse_decode_bool(deserializer);
    var var_canvas = sse_decode_list_prim_u_32_strict(deserializer);
    var var_overflowX = sse_decode_list_prim_i_32_strict(deserializer);
    var var_overflowY = sse_decode_list_prim_i_32_strict(deserializer);
    var var_overflowColor = sse_decode_list_prim_u_32_strict(deserializer);
    return CpuTransformTranslateResult(
      ok: var_ok,
      canvas: var_canvas,
      overflowX: var_overflowX,
      overflowY: var_overflowY,
      overflowColor: var_overflowColor,
    );
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  FloodFillPatch sse_decode_flood_fill_patch(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_left = sse_decode_i_32(deserializer);
    var var_top = sse_decode_i_32(deserializer);
    var var_width = sse_decode_i_32(deserializer);
    var var_height = sse_decode_i_32(deserializer);
    var var_pixels = sse_decode_list_prim_u_32_strict(deserializer);
    return FloodFillPatch(
      left: var_left,
      top: var_top,
      width: var_width,
      height: var_height,
      pixels: var_pixels,
    );
  }

  @protected
  FloodFillRect sse_decode_flood_fill_rect(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_left = sse_decode_i_32(deserializer);
    var var_top = sse_decode_i_32(deserializer);
    var var_width = sse_decode_i_32(deserializer);
    var var_height = sse_decode_i_32(deserializer);
    return FloodFillRect(
      left: var_left,
      top: var_top,
      width: var_width,
      height: var_height,
    );
  }

  @protected
  GpuLayerData sse_decode_gpu_layer_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_pixels = sse_decode_list_prim_u_32_strict(deserializer);
    var var_opacity = sse_decode_f_64(deserializer);
    var var_blendModeIndex = sse_decode_u_32(deserializer);
    var var_visible = sse_decode_bool(deserializer);
    var var_clippingMask = sse_decode_bool(deserializer);
    return GpuLayerData(
      pixels: var_pixels,
      opacity: var_opacity,
      blendModeIndex: var_blendModeIndex,
      visible: var_visible,
      clippingMask: var_clippingMask,
    );
  }

  @protected
  GpuPoint2D sse_decode_gpu_point_2_d(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_x = sse_decode_f_32(deserializer);
    var var_y = sse_decode_f_32(deserializer);
    return GpuPoint2D(x: var_x, y: var_y);
  }

  @protected
  GpuStrokeResult sse_decode_gpu_stroke_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_dirtyLeft = sse_decode_i_32(deserializer);
    var var_dirtyTop = sse_decode_i_32(deserializer);
    var var_dirtyWidth = sse_decode_i_32(deserializer);
    var var_dirtyHeight = sse_decode_i_32(deserializer);
    var var_drawCalls = sse_decode_u_32(deserializer);
    return GpuStrokeResult(
      dirtyLeft: var_dirtyLeft,
      dirtyTop: var_dirtyTop,
      dirtyWidth: var_dirtyWidth,
      dirtyHeight: var_dirtyHeight,
      drawCalls: var_drawCalls,
    );
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<CpuBrushCommand> sse_decode_list_cpu_brush_command(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CpuBrushCommand>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_cpu_brush_command(deserializer));
    }
    return ans_;
  }

  @protected
  List<GpuLayerData> sse_decode_list_gpu_layer_data(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GpuLayerData>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_gpu_layer_data(deserializer));
    }
    return ans_;
  }

  @protected
  List<GpuPoint2D> sse_decode_list_gpu_point_2_d(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GpuPoint2D>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_gpu_point_2_d(deserializer));
    }
    return ans_;
  }

  @protected
  List<double> sse_decode_list_prim_f_32_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  Float32List sse_decode_list_prim_f_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat32List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_i_32_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt32List(len_);
  }

  @protected
  Int32List sse_decode_list_prim_i_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt32List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_32_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  Uint32List sse_decode_list_prim_u_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<PsdLayer> sse_decode_list_psd_layer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PsdLayer>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_psd_layer(deserializer));
    }
    return ans_;
  }

  @protected
  List<WorkspaceEntry> sse_decode_list_workspace_entry(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WorkspaceEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_workspace_entry(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  WorkspaceEntry? sse_decode_opt_box_autoadd_workspace_entry(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_workspace_entry(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint32List? sse_decode_opt_list_prim_u_32_strict(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_32_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PsdDocument sse_decode_psd_document(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_width = sse_decode_i_32(deserializer);
    var var_height = sse_decode_i_32(deserializer);
    var var_layers = sse_decode_list_psd_layer(deserializer);
    return PsdDocument(
      width: var_width,
      height: var_height,
      layers: var_layers,
    );
  }

  @protected
  PsdLayer sse_decode_psd_layer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_visible = sse_decode_bool(deserializer);
    var var_opacity = sse_decode_u_8(deserializer);
    var var_clippingMask = sse_decode_bool(deserializer);
    var var_blendModeKey = sse_decode_String(deserializer);
    var var_bitmap = sse_decode_list_prim_u_8_strict(deserializer);
    var var_bitmapWidth = sse_decode_i_32(deserializer);
    var var_bitmapHeight = sse_decode_i_32(deserializer);
    var var_bitmapLeft = sse_decode_i_32(deserializer);
    var var_bitmapTop = sse_decode_i_32(deserializer);
    return PsdLayer(
      name: var_name,
      visible: var_visible,
      opacity: var_opacity,
      clippingMask: var_clippingMask,
      blendModeKey: var_blendModeKey,
      bitmap: var_bitmap,
      bitmapWidth: var_bitmapWidth,
      bitmapHeight: var_bitmapHeight,
      bitmapLeft: var_bitmapLeft,
      bitmapTop: var_bitmapTop,
    );
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WorkspaceEntry sse_decode_workspace_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_isDirty = sse_decode_bool(deserializer);
    return WorkspaceEntry(id: var_id, name: var_name, isDirty: var_isDirty);
  }

  @protected
  WorkspaceState sse_decode_workspace_state(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_entries = sse_decode_list_workspace_entry(deserializer);
    var var_activeId = sse_decode_opt_String(deserializer);
    return WorkspaceState(entries: var_entries, activeId: var_activeId);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_workspace_entry(
    WorkspaceEntry self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_workspace_entry(self, serializer);
  }

  @protected
  void sse_encode_cpu_blend_overflow_result(
    CpuBlendOverflowResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.ok, serializer);
    sse_encode_list_prim_u_32_strict(self.canvas, serializer);
    sse_encode_list_prim_i_32_strict(self.outX, serializer);
    sse_encode_list_prim_i_32_strict(self.outY, serializer);
    sse_encode_list_prim_u_32_strict(self.outColor, serializer);
  }

  @protected
  void sse_encode_cpu_blend_result(
    CpuBlendResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.ok, serializer);
    sse_encode_list_prim_u_32_strict(self.canvas, serializer);
  }

  @protected
  void sse_encode_cpu_brush_command(
    CpuBrushCommand self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.kind, serializer);
    sse_encode_f_32(self.ax, serializer);
    sse_encode_f_32(self.ay, serializer);
    sse_encode_f_32(self.bx, serializer);
    sse_encode_f_32(self.by, serializer);
    sse_encode_f_32(self.startRadius, serializer);
    sse_encode_f_32(self.endRadius, serializer);
    sse_encode_f_32(self.centerX, serializer);
    sse_encode_f_32(self.centerY, serializer);
    sse_encode_f_32(self.radius, serializer);
    sse_encode_u_32(self.colorArgb, serializer);
    sse_encode_u_32(self.brushShape, serializer);
    sse_encode_u_32(self.antialiasLevel, serializer);
    sse_encode_f_32(self.softness, serializer);
    sse_encode_bool(self.erase, serializer);
    sse_encode_bool(self.includeStartCap, serializer);
    sse_encode_bool(self.includeStart, serializer);
    sse_encode_bool(self.randomRotation, serializer);
    sse_encode_bool(self.smoothRotation, serializer);
    sse_encode_u_32(self.rotationSeed, serializer);
    sse_encode_f_32(self.rotationJitter, serializer);
    sse_encode_f_32(self.spacing, serializer);
    sse_encode_f_32(self.scatter, serializer);
    sse_encode_bool(self.screentoneEnabled, serializer);
    sse_encode_f_32(self.screentoneSpacing, serializer);
    sse_encode_f_32(self.screentoneDotSize, serializer);
    sse_encode_f_32(self.screentoneRotation, serializer);
    sse_encode_f_32(self.screentoneSoftness, serializer);
    sse_encode_bool(self.snapToPixel, serializer);
  }

  @protected
  void sse_encode_cpu_brush_result(
    CpuBrushResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.ok, serializer);
    sse_encode_list_prim_u_32_strict(self.pixels, serializer);
  }

  @protected
  void sse_encode_cpu_filters_bytes_result(
    CpuFiltersBytesResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.ok, serializer);
    sse_encode_list_prim_u_8_strict(self.pixels, serializer);
  }

  @protected
  void sse_encode_cpu_filters_result(
    CpuFiltersResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.ok, serializer);
    sse_encode_list_prim_u_32_strict(self.pixels, serializer);
  }

  @protected
  void sse_encode_cpu_image_bounds_result(
    CpuImageBoundsResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.ok, serializer);
    sse_encode_list_prim_i_32_strict(self.bounds, serializer);
  }

  @protected
  void sse_encode_cpu_streamline_result(
    CpuStreamlineResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.ok, serializer);
    sse_encode_list_prim_f_32_strict(self.samples, serializer);
  }

  @protected
  void sse_encode_cpu_transform_snapshot_result(
    CpuTransformSnapshotResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.ok, serializer);
    sse_encode_list_prim_u_32_strict(self.snapshot, serializer);
  }

  @protected
  void sse_encode_cpu_transform_translate_result(
    CpuTransformTranslateResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.ok, serializer);
    sse_encode_list_prim_u_32_strict(self.canvas, serializer);
    sse_encode_list_prim_i_32_strict(self.overflowX, serializer);
    sse_encode_list_prim_i_32_strict(self.overflowY, serializer);
    sse_encode_list_prim_u_32_strict(self.overflowColor, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_flood_fill_patch(
    FloodFillPatch self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.left, serializer);
    sse_encode_i_32(self.top, serializer);
    sse_encode_i_32(self.width, serializer);
    sse_encode_i_32(self.height, serializer);
    sse_encode_list_prim_u_32_strict(self.pixels, serializer);
  }

  @protected
  void sse_encode_flood_fill_rect(
    FloodFillRect self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.left, serializer);
    sse_encode_i_32(self.top, serializer);
    sse_encode_i_32(self.width, serializer);
    sse_encode_i_32(self.height, serializer);
  }

  @protected
  void sse_encode_gpu_layer_data(GpuLayerData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_32_strict(self.pixels, serializer);
    sse_encode_f_64(self.opacity, serializer);
    sse_encode_u_32(self.blendModeIndex, serializer);
    sse_encode_bool(self.visible, serializer);
    sse_encode_bool(self.clippingMask, serializer);
  }

  @protected
  void sse_encode_gpu_point_2_d(GpuPoint2D self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self.x, serializer);
    sse_encode_f_32(self.y, serializer);
  }

  @protected
  void sse_encode_gpu_stroke_result(
    GpuStrokeResult self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.dirtyLeft, serializer);
    sse_encode_i_32(self.dirtyTop, serializer);
    sse_encode_i_32(self.dirtyWidth, serializer);
    sse_encode_i_32(self.dirtyHeight, serializer);
    sse_encode_u_32(self.drawCalls, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_list_cpu_brush_command(
    List<CpuBrushCommand> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_cpu_brush_command(item, serializer);
    }
  }

  @protected
  void sse_encode_list_gpu_layer_data(
    List<GpuLayerData> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_gpu_layer_data(item, serializer);
    }
  }

  @protected
  void sse_encode_list_gpu_point_2_d(
    List<GpuPoint2D> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_gpu_point_2_d(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_32_loose(
    List<double> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(
      self is Float32List ? self : Float32List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_f_32_strict(
    Float32List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat32List(self);
  }

  @protected
  void sse_encode_list_prim_i_32_loose(
    List<int> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt32List(
      self is Int32List ? self : Int32List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_i_32_strict(
    Int32List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt32List(self);
  }

  @protected
  void sse_encode_list_prim_u_32_loose(
    List<int> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint32List(
      self is Uint32List ? self : Uint32List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_u_32_strict(
    Uint32List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
    List<int> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(
      self is Uint8List ? self : Uint8List.fromList(self),
    );
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_psd_layer(
    List<PsdLayer> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_psd_layer(item, serializer);
    }
  }

  @protected
  void sse_encode_list_workspace_entry(
    List<WorkspaceEntry> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_workspace_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_workspace_entry(
    WorkspaceEntry? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_workspace_entry(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_32_strict(
    Uint32List? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_32_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
    Uint8List? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_psd_document(PsdDocument self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.width, serializer);
    sse_encode_i_32(self.height, serializer);
    sse_encode_list_psd_layer(self.layers, serializer);
  }

  @protected
  void sse_encode_psd_layer(PsdLayer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_bool(self.visible, serializer);
    sse_encode_u_8(self.opacity, serializer);
    sse_encode_bool(self.clippingMask, serializer);
    sse_encode_String(self.blendModeKey, serializer);
    sse_encode_list_prim_u_8_strict(self.bitmap, serializer);
    sse_encode_i_32(self.bitmapWidth, serializer);
    sse_encode_i_32(self.bitmapHeight, serializer);
    sse_encode_i_32(self.bitmapLeft, serializer);
    sse_encode_i_32(self.bitmapTop, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_workspace_entry(
    WorkspaceEntry self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_bool(self.isDirty, serializer);
  }

  @protected
  void sse_encode_workspace_state(
    WorkspaceState self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_workspace_entry(self.entries, serializer);
    sse_encode_opt_String(self.activeId, serializer);
  }
}
