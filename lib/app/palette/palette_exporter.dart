import 'dart:convert';
import 'dart:math' as math;
import 'dart:typed_data';
import 'dart:ui' show Color;

class PaletteExportException implements Exception {
  PaletteExportException(this.message);

  final String message;

  @override
  String toString() => message;
}

enum PaletteExportFormat { gimp, aseprite }

class PaletteFileExporter {
  const PaletteFileExporter._();

  static Uint8List encode({
    required PaletteExportFormat format,
    required String paletteName,
    required List<Color> colors,
  }) {
    if (colors.isEmpty) {
      throw PaletteExportException('调色盘没有可导出的颜色。');
    }
    switch (format) {
      case PaletteExportFormat.gimp:
        return _encodeGimpPalette(paletteName, colors);
      case PaletteExportFormat.aseprite:
        return _encodeAsepritePalette(colors);
    }
  }

  static Uint8List _encodeGimpPalette(String paletteName, List<Color> colors) {
    final String name = paletteName.trim().isEmpty ? '调色盘' : paletteName.trim();
    final StringBuffer buffer = StringBuffer()
      ..writeln('GIMP Palette')
      ..writeln('Name: $name')
      ..writeln('Columns: ${math.min(16, math.max(1, colors.length))}')
      ..writeln('# Generated by Misa Rin');
    for (final Color color in colors) {
      final int r = _componentToUint8(color.r);
      final int g = _componentToUint8(color.g);
      final int b = _componentToUint8(color.b);
      buffer.writeln(
        '${r.toString().padLeft(3)} ${g.toString().padLeft(3)} ${b.toString().padLeft(3)}',
      );
    }
    return utf8.encode(buffer.toString());
  }

  static Uint8List _encodeAsepritePalette(List<Color> colors) {
    final int paletteSize = colors.length;
    final int canvasWidth = math.max(1, paletteSize);

    final BytesBuilder builder = BytesBuilder();
    final ByteData headerData = ByteData(128);
    headerData.setUint32(0, 0, Endian.little); // Placeholder for file size
    headerData.setUint16(4, 0xA5E0, Endian.little); // Magic
    headerData.setUint16(6, 1, Endian.little); // Frame count
    headerData.setUint16(8, canvasWidth.clamp(1, 0xFFFF), Endian.little); // Width
    headerData.setUint16(10, 1, Endian.little); // Height
    headerData.setUint16(12, 32, Endian.little); // Color depth (RGBA)
    headerData.setUint32(14, 1, Endian.little); // Flags (layer opacity valid)
    headerData.setUint16(18, 1, Endian.little); // Speed (ms)
    headerData.setUint32(20, 0, Endian.little); // Reserved
    headerData.setUint32(24, 0, Endian.little); // Reserved
    headerData.setUint8(28, 0); // Transparent color index
    headerData.setUint8(29, 0);
    headerData.setUint8(30, 0);
    headerData.setUint8(31, 0);
    headerData.setUint16(32, paletteSize.clamp(0, 0xFFFF), Endian.little);
    headerData.setUint8(34, 1); // Pixel width
    headerData.setUint8(35, 1); // Pixel height
    headerData.setInt16(36, 0); // Grid x
    headerData.setInt16(38, 0); // Grid y
    headerData.setUint16(40, canvasWidth.clamp(1, 0xFFFF), Endian.little);
    headerData.setUint16(42, 1, Endian.little);
    builder.add(headerData.buffer.asUint8List());

    final int entryCount = paletteSize;
    final int chunkDataSize = 4 + 4 + 4 + 8 + entryCount * 6;
    final int chunkSize = chunkDataSize + 6;
    final int frameBytes = 16 + chunkSize;

    final ByteData frameHeader = ByteData(16);
    frameHeader.setUint32(0, frameBytes, Endian.little);
    frameHeader.setUint16(4, 0xF1FA, Endian.little);
    frameHeader.setUint16(6, 1, Endian.little); // Old chunk count
    frameHeader.setUint16(8, 0, Endian.little); // Frame duration
    frameHeader.setUint16(10, 0, Endian.little); // Reserved
    frameHeader.setUint32(12, 1, Endian.little); // New chunk count
    builder.add(frameHeader.buffer.asUint8List());

    final ByteData chunkHeader = ByteData(6);
    chunkHeader.setUint32(0, chunkSize, Endian.little);
    chunkHeader.setUint16(4, 0x2019, Endian.little);
    builder.add(chunkHeader.buffer.asUint8List());

    final ByteData chunkFixed = ByteData(20);
    chunkFixed.setUint32(0, entryCount, Endian.little);
    chunkFixed.setUint32(4, 0, Endian.little); // First color index
    chunkFixed.setUint32(8, entryCount == 0 ? 0 : entryCount - 1, Endian.little);
    builder.add(chunkFixed.buffer.asUint8List());

    for (final Color color in colors) {
      final int r = _componentToUint8(color.r);
      final int g = _componentToUint8(color.g);
      final int b = _componentToUint8(color.b);
      final int a = _componentToUint8(color.a);
      final ByteData entry = ByteData(6);
      entry.setUint16(0, 0, Endian.little); // Flags
      entry.setUint8(2, r);
      entry.setUint8(3, g);
      entry.setUint8(4, b);
      entry.setUint8(5, a);
      builder.add(entry.buffer.asUint8List());
    }

    final Uint8List bytes = builder.toBytes();
    final ByteData view = ByteData.sublistView(bytes);
    view.setUint32(0, bytes.lengthInBytes, Endian.little);
    return bytes;
  }
}

int _componentToUint8(double component) {
  final double clamped = component.clamp(0.0, 1.0);
  final int rounded = (clamped * 255.0).round();
  if (rounded < 0) {
    return 0;
  }
  if (rounded > 255) {
    return 255;
  }
  return rounded;
}
