import 'dart:convert';
import 'dart:math' as math;
import 'dart:typed_data';

import 'package:fluent_ui/fluent_ui.dart';

class PaletteExportException implements Exception {
  PaletteExportException(this.message);

  final String message;

  @override
  String toString() => message;
}

enum PaletteExportFormat { gimp, aseprite }

class PaletteFileExporter {
  const PaletteFileExporter._();

  static Uint8List encode({
    required PaletteExportFormat format,
    required String paletteName,
    required List<Color> colors,
  }) {
    if (colors.isEmpty) {
      throw PaletteExportException('调色盘没有可导出的颜色。');
    }
    switch (format) {
      case PaletteExportFormat.gimp:
        return _encodeGimpPalette(paletteName, colors);
      case PaletteExportFormat.aseprite:
        return _encodeAsepritePalette(colors);
    }
  }

  static Uint8List _encodeGimpPalette(String paletteName, List<Color> colors) {
    final String name = paletteName.trim().isEmpty ? '调色盘' : paletteName.trim();
    final StringBuffer buffer = StringBuffer()
      ..writeln('GIMP Palette')
      ..writeln('Name: $name')
      ..writeln('Columns: ${math.min(16, math.max(1, colors.length))}')
      ..writeln('# Generated by Misa Rin');
    for (final Color color in colors) {
      buffer.writeln(
        '${color.red.toString().padLeft(3)} ${color.green.toString().padLeft(3)} ${color.blue.toString().padLeft(3)}',
      );
    }
    return utf8.encode(buffer.toString());
  }

  static Uint8List _encodeAsepritePalette(List<Color> colors) {
    final BytesBuilder builder = BytesBuilder();
    final Uint8List header = Uint8List(128);
    final ByteData headerData = ByteData.sublistView(header);
    headerData.setUint32(0, 0, Endian.little); // file size placeholder
    headerData.setUint16(4, 0xA5E0, Endian.little);
    headerData.setUint16(6, 1, Endian.little); // frame count
    builder.add(header);

    final int paletteSize = colors.length;
    final int chunkDataSize = 4 + 4 + 4 + 8 + paletteSize * 6;
    final int chunkSize = chunkDataSize + 6;
    final int frameBytes = 20 + chunkSize;

    final ByteData frameHeader = ByteData(20);
    frameHeader.setUint32(0, frameBytes, Endian.little);
    frameHeader.setUint16(4, 0xF1FA, Endian.little);
    frameHeader.setUint16(6, 1, Endian.little); // old chunk count
    frameHeader.setUint16(8, 0, Endian.little); // frame duration
    frameHeader.setUint16(10, 0, Endian.little); // reserved
    frameHeader.setUint32(12, 1, Endian.little); // chunk count
    frameHeader.setUint32(16, 0, Endian.little); // reserved
    builder.add(frameHeader.buffer.asUint8List());

    final ByteData chunkHeader = ByteData(6);
    chunkHeader.setUint32(0, chunkSize, Endian.little);
    chunkHeader.setUint16(4, 0x2019, Endian.little);
    builder.add(chunkHeader.buffer.asUint8List());

    final ByteData chunkFixed = ByteData(20);
    chunkFixed.setUint32(0, paletteSize, Endian.little);
    chunkFixed.setUint32(4, 0, Endian.little); // first color index
    chunkFixed.setUint32(8, math.max(0, paletteSize - 1), Endian.little);
    // The remaining 8 bytes are reserved zeros.
    builder.add(chunkFixed.buffer.asUint8List());

    for (final Color color in colors) {
      final Uint8List entry = Uint8List(6);
      final ByteData entryData = ByteData.sublistView(entry);
      entryData.setUint16(0, 0, Endian.little); // flags
      entryData.setUint8(2, color.red);
      entryData.setUint8(3, color.green);
      entryData.setUint8(4, color.blue);
      entryData.setUint8(5, color.alpha);
      builder.add(entry);
    }

    final Uint8List bytes = builder.toBytes();
    final ByteData view = ByteData.sublistView(bytes);
    view.setUint32(0, bytes.lengthInBytes, Endian.little);
    return bytes;
  }
}
