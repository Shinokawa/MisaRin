import 'dart:convert';
import 'dart:math' as math;
import 'dart:typed_data';
import 'dart:ui' show Color;

class PaletteExportException implements Exception {
  PaletteExportException(this.message);

  final String message;

  @override
  String toString() => message;
}

enum PaletteExportFormat { gimp, aseprite }

class PaletteFileExporter {
  const PaletteFileExporter._();

  static Uint8List encode({
    required PaletteExportFormat format,
    required String paletteName,
    required List<Color> colors,
  }) {
    if (colors.isEmpty) {
      throw PaletteExportException('调色盘没有可导出的颜色。');
    }
    switch (format) {
      case PaletteExportFormat.gimp:
        return _encodeGimpPalette(paletteName, colors);
      case PaletteExportFormat.aseprite:
        return _encodeAsepritePalette(colors);
    }
  }

  static Uint8List _encodeGimpPalette(String paletteName, List<Color> colors) {
    final String name = paletteName.trim().isEmpty ? '调色盘' : paletteName.trim();
    final StringBuffer buffer = StringBuffer()
      ..writeln('GIMP Palette')
      ..writeln('Name: $name')
      ..writeln('Columns: ${math.min(16, math.max(1, colors.length))}')
      ..writeln('# Generated by Misa Rin');
    for (final Color color in colors) {
      final int r = _componentToUint8(color.r);
      final int g = _componentToUint8(color.g);
      final int b = _componentToUint8(color.b);
      buffer.writeln(
        '${r.toString().padLeft(3)} ${g.toString().padLeft(3)} ${b.toString().padLeft(3)}',
      );
    }
    return utf8.encode(buffer.toString());
  }

  static Uint8List _encodeAsepritePalette(List<Color> colors) {
    final BytesBuilder builder = BytesBuilder();
    final Uint8List header = Uint8List(128);
    final ByteData headerData = ByteData.sublistView(header);
    headerData.setUint32(0, 0, Endian.little); // file size placeholder
    headerData.setUint16(4, 0xA5E0, Endian.little);
    headerData.setUint16(6, 1, Endian.little); // frame count
    builder.add(header);

    final int paletteSize = colors.length;
    final int chunkDataSize = 4 + 4 + 4 + 8 + paletteSize * 6;
    final int chunkSize = chunkDataSize + 6;
    final int frameBytes = 20 + chunkSize;

    final ByteData frameHeader = ByteData(20);
    frameHeader.setUint32(0, frameBytes, Endian.little);
    frameHeader.setUint16(4, 0xF1FA, Endian.little);
    frameHeader.setUint16(6, 1, Endian.little); // old chunk count
    frameHeader.setUint16(8, 0, Endian.little); // frame duration
    frameHeader.setUint16(10, 0, Endian.little); // reserved
    frameHeader.setUint32(12, 1, Endian.little); // chunk count
    frameHeader.setUint32(16, 0, Endian.little); // reserved
    builder.add(frameHeader.buffer.asUint8List());

    final ByteData chunkHeader = ByteData(6);
    chunkHeader.setUint32(0, chunkSize, Endian.little);
    chunkHeader.setUint16(4, 0x2019, Endian.little);
    builder.add(chunkHeader.buffer.asUint8List());

    final ByteData chunkFixed = ByteData(20);
    chunkFixed.setUint32(0, paletteSize, Endian.little);
    chunkFixed.setUint32(4, 0, Endian.little); // first color index
    chunkFixed.setUint32(8, math.max(0, paletteSize - 1), Endian.little);
    // The remaining 8 bytes are reserved zeros.
    builder.add(chunkFixed.buffer.asUint8List());

    for (final Color color in colors) {
      final int r = _componentToUint8(color.r);
      final int g = _componentToUint8(color.g);
      final int b = _componentToUint8(color.b);
      final int a = _componentToUint8(color.a);
      final Uint8List entry = Uint8List(6);
      final ByteData entryData = ByteData.sublistView(entry);
      entryData.setUint16(0, 0, Endian.little); // flags
      entryData.setUint8(2, r);
      entryData.setUint8(3, g);
      entryData.setUint8(4, b);
      entryData.setUint8(5, a);
      builder.add(entry);
    }

    final Uint8List bytes = builder.toBytes();
    final ByteData view = ByteData.sublistView(bytes);
    view.setUint32(0, bytes.lengthInBytes, Endian.little);
    return bytes;
  }
}

int _componentToUint8(double component) {
  final double clamped = component.clamp(0.0, 1.0);
  final int rounded = (clamped * 255.0).round();
  if (rounded < 0) {
    return 0;
  }
  if (rounded > 255) {
    return 255;
  }
  return rounded;
}
